<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Potassium UI</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
        :root {
            --bg-primary: #181818; --bg-secondary: #1a1a1a; --bg-tertiary: #2a2a2a;
            --bg-accent: #222; --bg-settings-hover: #252525;
            --btn-g1: #1f1f1f; --btn-g2: #1c1c1c; --btn-g3: #1b1b1b;
            --btn-hg1: #2a2a2a; --btn-hg2: #252525; --btn-hg3: #222;
            --toggle-bg: #3a3a3c; --toggle-on: #909090; --toggle-border: #505050; --toggle-on-border: #606060;
            --toggle-knob-off: #888; --toggle-knob-on: #fff;
            --text-primary: #d0d0d0; --text-secondary: #888; --text-tertiary: #606060;
            --text-btn: #b0b0b0; --text-btn-h: #d4d4d4; --text-title: #ccc; --text-active-tab: #d0d0d0;
            --border-primary: #282828; --border-secondary: #1f1f1f; --border-accent: #303030;
            --theme-border: #333; --theme-border-active: #888888;
            --icon-primary: #777; --icon-hover: #a0a0a0; --icon-active: #fff;
            --icon-search: #7f7f7f; --icon-tab-close: #707070; --icon-tab-close-h: #bbb;
            --icon-add-tab: #707070; --icon-add-tab-h: #999;
            --icon-btn: #b0b0b0; --icon-btn-h: #e0e0e0;
            --accent: #a0a0a0; --accent-dim: #555555; --red: #b85555;
            --dd-bg: #1e1e1e; --dd-border: #2e2e2e; --dd-hover: #272727; --dd-text: #c8c8c8;
            --dot-off: #444; --dot-muted: #555;
            --badge-bg: rgba(255,255,255,.04);
            --conn-bg: rgba(160,160,160,.06);
            --overlay-bg: rgba(0,0,0,.6);
            --shadow-panel: 0 10px 28px rgba(0,0,0,.55);
            --shadow-panel-strong: 0 10px 30px rgba(0,0,0,.6);
            --shadow-modal: 0 14px 42px rgba(0,0,0,.6);
            --theme-glow: 0 0 10px rgba(160,160,160,.12);
        }
        .light-theme {
            --bg-primary: #fff; --bg-secondary: #f0f0f0; --bg-tertiary: #e0e0e0;
            --bg-accent: #ddd; --bg-settings-hover: #e5e5e5;
            --btn-g1: #f0f0f0; --btn-g2: #e8e8e8; --btn-g3: #e0e0e0;
            --btn-hg1: #ddd; --btn-hg2: #d0d0d0; --btn-hg3: #c8c8c8;
            --toggle-bg: #d0d0d0; --toggle-on: #3a3a3a; --toggle-on-border: #222; --toggle-border: #bbb; --theme-border-active: #3a3a3a;
            --toggle-knob-off: #888; --toggle-knob-on: #fff;
            --text-primary: #222; --text-secondary: #555; --text-tertiary: #666;
            --text-btn: #333; --text-btn-h: #000; --text-title: #333; --text-active-tab: #000;
            --border-primary: #ccc; --border-secondary: #dcdcdc; --border-accent: #b0b0b0;
            --theme-border: #ccc; --icon-primary: #555; --icon-hover: #222; --icon-active: #000;
            --icon-search: #555; --icon-tab-close: #666; --icon-tab-close-h: #000;
            --icon-add-tab: #666; --icon-add-tab-h: #333; --icon-btn: #333; --icon-btn-h: #000;
            --accent: #3a3a3a; --accent-dim: #222222; --red: #b04040;
            --dd-bg: #f5f5f5; --dd-border: #ccc; --dd-hover: #e0e0e0; --dd-text: #222;
            --dot-off: #999; --dot-muted: #888;
            --badge-bg: rgba(0,0,0,.06);
            --conn-bg: rgba(0,0,0,.06);
            --overlay-bg: rgba(0,0,0,.35);
            --shadow-panel: 0 10px 28px rgba(0,0,0,.18);
            --shadow-panel-strong: 0 10px 30px rgba(0,0,0,.20);
            --shadow-modal: 0 14px 42px rgba(0,0,0,.22);
            --theme-glow: 0 0 10px rgba(0,0,0,.08);
        }
        *, *::before, *::after { box-sizing: border-box; }
        body { font-family: 'Inter', sans-serif; background: var(--bg-primary); margin: 0; padding: 0; display: flex; align-items: center; justify-content: center; min-height: 100vh; color: var(--text-primary); overflow: hidden; }
        #app-container { width: 100vw; height: 100vh; background: var(--bg-primary); display: flex; flex-direction: column; overflow: hidden; transition: background .3s; }

        /* ── TITLE BAR ── */
        /* Only the top title-bar is draggable so tab scrolling/dragging works. */
        #app-header { background: var(--bg-primary); -webkit-app-region: no-drag; }
        .title-bar { -webkit-app-region: drag; }
        .title-bar { display: flex; align-items: center; justify-content: space-between; padding: 4px 10px; height: 30px; position: relative; }
        .title { font-size: 13px; font-weight: 500; color: var(--text-title); }
        .top-center-actions { display: flex; align-items: center; gap: 22px; position: absolute; left: 50%; transform: translateX(-50%); -webkit-app-region: no-drag; }
        .action-icon-wrapper { position: relative; padding-bottom: 6px; cursor: pointer; display: flex; align-items: center; justify-content: center; }
        .action-icon-wrapper svg { width: 20px; height: 20px; stroke: var(--icon-primary); stroke-width: 2; fill: none; transition: stroke .2s; display: block; }
        .action-icon-wrapper:hover svg { stroke: var(--icon-hover); }
        .action-icon-wrapper.palette-icon svg circle { fill: var(--icon-primary); stroke: none; transition: fill .2s; }
        .action-icon-wrapper.palette-icon svg path { stroke: var(--icon-primary); fill: none; }
        .action-icon-wrapper.palette-icon:hover svg circle { fill: var(--icon-hover); }
        .action-icon-wrapper.palette-icon:hover svg path { stroke: var(--icon-hover); }
        .action-icon-wrapper.wrench-icon svg { transform: scaleX(-1); }
        .action-icon-wrapper.active-section-indicator svg { stroke: var(--icon-active); }
        .action-icon-wrapper.active-section-indicator.palette-icon svg path { stroke: var(--icon-active); }
        .action-icon-wrapper.active-section-indicator.palette-icon svg circle { fill: var(--icon-active); }
        .action-icon-wrapper.palette-icon:not(.active-section-indicator) svg path { stroke: var(--icon-primary); }
        .action-icon-wrapper.palette-icon:not(.active-section-indicator) svg circle { fill: var(--icon-primary); }
        .action-icon-wrapper.palette-icon:not(.active-section-indicator):hover svg path { stroke: var(--icon-hover); }
        .action-icon-wrapper.palette-icon:not(.active-section-indicator):hover svg circle { fill: var(--icon-hover); }
        .action-icon-wrapper.active-section-indicator::after { content: ''; display: block; width: 100%; height: 3px; background: var(--icon-active); position: absolute; bottom: 0; left: 50%; transform: translateX(-50%); border-radius: 1px; }
        .title-bar-window-controls { display: flex; align-items: center; -webkit-app-region: no-drag; margin-left: auto; }
        .title-bar-window-controls svg { width: 16px; height: 16px; stroke: var(--icon-primary); stroke-width: 1.5; fill: none; margin-left: 18px; cursor: pointer; transition: stroke .2s; }
        .title-bar-window-controls svg:hover { stroke: var(--icon-hover); }
        #wcbtn-close:hover { stroke: var(--red) !important; }

        /* ── TAB BAR ── */
        #tab-bar { background: var(--bg-primary); display: flex; align-items: center; padding: 0 4px 0 0; height: 34px; overflow: hidden; -webkit-app-region: no-drag; }
        #tabs-and-add { display: flex; align-items: flex-end; flex-grow: 1; height: 100%; overflow: hidden; position: relative; }
        #tabs-container { display: flex; align-items: flex-end; overflow-x: auto; overflow-y: hidden; scrollbar-width: none; height: 100%; max-width: calc(100% - 30px); -webkit-app-region: no-drag; }
        #tabs-container::-webkit-scrollbar { display: none; }

        /* Custom overlay scrollbar (does not affect layout) */
        #tabs-scrollbar { position: absolute; left: 6px; right: 6px; bottom: 2px; height: 6px; border-radius: 999px; background: var(--bg-accent); pointer-events: auto; opacity: .9; display: none; z-index: 10; }
        #tabs-scrollbar:hover { opacity: 1; }
        #tabs-scrollbar-thumb { position: absolute; left: 0; top: 0; height: 100%; border-radius: 999px; background: var(--accent); min-width: 24px; }
        .tab { display: flex; align-items: center; padding: 8px 10px; margin-right: 1px; background: var(--bg-primary); color: var(--text-secondary); font-size: 12px; cursor: pointer; border: none; position: relative; bottom: -1px; max-width: 160px; white-space: nowrap; overflow: hidden; line-height: 1; flex-shrink: 0; }
        .tab.active { background: var(--bg-tertiary); color: var(--text-active-tab); z-index: 1; }
        .tab-icon { margin-right: 6px; width: 14px; height: 14px; fill: currentColor; stroke: none; opacity: 0.7; flex-shrink: 0; }
        .active .tab-icon { opacity: 1; }
        .tab-name { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .tab-name-input { background: var(--bg-tertiary); color: var(--text-active-tab); border: 1px solid var(--border-accent); font-size: 12px; width: 90px; }
        .tab-close-btn { margin-left: 6px; color: var(--icon-tab-close); font-size: 16px; font-weight: 300; background: transparent !important; border: none; padding: 0 2px; cursor: pointer; line-height: 1; flex-shrink: 0; }
        .tab-close-btn:hover { color: var(--icon-tab-close-h); }
        #add-tab-btn { color: var(--icon-add-tab); font-size: 20px; padding: 0 8px; background: transparent !important; border: none; cursor: pointer; display: flex; align-items: center; height: 100%; margin-left: 2px; flex-shrink: 0; position: relative; bottom: -1px; }
        #add-tab-btn:hover { color: var(--icon-add-tab-h); }
        #tab-bar-search-container { display: flex; align-items: center; background-color: var(--bg-accent); border: none; border-radius: 4px; padding: 0 8px; margin-left: auto; height: 26px; width: 210px; flex-shrink: 0; }
        #tab-bar-search-container svg { width: 14px; height: 14px; stroke: var(--icon-search); stroke-width: 2; fill: none; margin-right: 6px; flex-shrink: 0; }
        #tab-bar-search-input { background: transparent; border: none; outline: none; color: var(--text-primary); font-size: 12px; flex-grow: 1; width: 100%; }
        #tab-bar-search-input::placeholder { color: var(--text-tertiary); }

        /* ── APP BODY ── */
        #app-body { flex-grow: 1; display: flex; overflow: hidden; position: relative; }
        #app-body.settings-active, #app-body.theme-active { border-top: none; }
        #editor-view { display: flex; width: 100%; height: 100%; }
        #main-editor { flex-grow: 1; display: flex; overflow: hidden; background: var(--bg-secondary); }
        #monaco-container { width: 100%; height: 100%; }
        #right-sidebar { width: 230px; flex-shrink: 0; background: var(--bg-secondary); border-left: 1px solid var(--border-secondary); height: 100%; box-sizing: border-box; display: flex; flex-direction: column; }
        #right-sidebar.hidden { display: none; }
        /* Outline sidebar */
        .outline-header { padding: 10px 12px 8px; font-size: 12px; font-weight: 600; color: var(--text-primary); border-bottom: 1px solid var(--border-secondary); }
        .outline-list { flex: 1; overflow: auto; padding: 8px 6px 10px; }
        /* Sidebar scrollbar uses sidebar colors (not accent) */
        .outline-list { scrollbar-width: thin; scrollbar-color: var(--bg-tertiary) var(--bg-secondary); }
        .outline-list::-webkit-scrollbar { width: 8px; height: 8px; }
        .outline-list::-webkit-scrollbar-track { background: var(--bg-secondary); border-radius: 999px; }
        .outline-list::-webkit-scrollbar-thumb { background: var(--bg-tertiary); border-radius: 999px; }
        .outline-list::-webkit-scrollbar-thumb:hover { background: var(--bg-accent); }
        .outline-group { margin: 8px 6px 6px; font-size: 10px; font-weight: 700; letter-spacing: .08em; text-transform: uppercase; color: var(--text-tertiary); display: flex; align-items: center; gap: 6px; }
        .outline-group-icon { width: 14px; height: 14px; display: inline-flex; align-items: center; justify-content: center; color: var(--text-tertiary); opacity: .9; }
        .outline-group-icon svg { display: block; }
        .outline-item { display: flex; align-items: center; gap: 8px; padding: 6px 8px; border-radius: 6px; cursor: pointer; color: var(--text-secondary); font-size: 12px; }
        .outline-item:hover { background: var(--bg-settings-hover); color: var(--text-primary); }
        .outline-indent { display: inline-block; width: 0; flex: 0 0 auto; }
        .outline-kind { width: 16px; height: 16px; display: inline-flex; align-items: center; justify-content: center; flex-shrink: 0; color: var(--text-tertiary); }
        .outline-kind svg { display: block; }
        .outline-kind.k-fn, .outline-kind.k-method, .outline-kind.k-ctor { color: var(--accent); }
        .outline-kind.k-class { color: #5a8a7a; }
        .outline-kind.k-interface { color: #557a8a; }
        .outline-kind.k-namespace, .outline-kind.k-module { color: #557a8a; }
        .outline-kind.k-enum { color: #8a7a55; }
        .outline-kind.k-var, .outline-kind.k-prop, .outline-kind.k-field { color: #8a8a8a; }
        .outline-kind.k-const { color: #8a7a55; }
        .outline-kind.k-str { color: #7a5a8a; }
        .outline-kind.k-num { color: #7a8a55; }
        .outline-kind.k-bool { color: #8a5555; }
        .outline-kind.k-arr, .outline-kind.k-obj { color: #5a6a8a; }
        .outline-empty { padding: 10px 10px; color: var(--text-tertiary); font-size: 12px; }

        /* ── SETTINGS / THEME VIEWS ── */
        #settings-view, #theme-view { width: 100%; height: 100%; background: var(--bg-primary); padding: 22px 26px; display: none; overflow-y: auto; }
        /* Themed scrollbars (Settings/Theme views) */
        #settings-view, #theme-view { scrollbar-width: thin; scrollbar-color: var(--accent) var(--bg-secondary); }
        #settings-view::-webkit-scrollbar, #theme-view::-webkit-scrollbar { width: 8px; height: 8px; }
        #settings-view::-webkit-scrollbar-track, #theme-view::-webkit-scrollbar-track { background: var(--bg-secondary); }
        #settings-view::-webkit-scrollbar-thumb, #theme-view::-webkit-scrollbar-thumb { background: var(--accent); border-radius: 999px; }
        #settings-view::-webkit-scrollbar-thumb:hover, #theme-view::-webkit-scrollbar-thumb:hover { background: var(--icon-hover); }
        .sec-title { font-size: 10.5px; font-weight: 700; letter-spacing: .09em; text-transform: uppercase; color: var(--text-tertiary); margin: 0 0 8px; }
        .sec-title:not(:first-child) { margin-top: 26px; }
        .sec-divider { height: 1px; background: var(--border-primary); margin-bottom: 10px; }
        .setting-row { display: flex; justify-content: space-between; align-items: center; padding: 10px 12px; border-radius: 7px; margin-bottom: 2px; transition: background .15s; }
        .setting-row:hover { background: var(--bg-settings-hover); }
        .setting-label { display: flex; flex-direction: column; gap: 2px; }
        .setting-label .lbl { font-size: 13.5px; font-weight: 500; color: var(--text-primary); }
        .setting-label .desc { font-size: 11.5px; color: var(--text-secondary); }
        .setting-action-btn { background: var(--bg-tertiary); color: var(--text-primary); border: 1px solid var(--border-accent); border-radius: 6px; padding: 6px 10px; font-size: 12px; font-family: inherit; cursor: pointer; }
        .setting-action-btn:hover { background: var(--bg-accent); }

        /* Toggle */
        .toggle-switch { position: relative; display: inline-block; width: 36px; height: 20px; cursor: pointer; flex-shrink: 0; }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; inset: 0; background: var(--toggle-bg); border: 1px solid var(--toggle-border); transition: .3s; border-radius: 20px; }
        .slider::before { content: ""; position: absolute; width: 14px; height: 14px; border-radius: 50%; background: var(--toggle-knob-off); bottom: 2px; left: 2px; transition: transform .3s, background .3s; }
        input:checked + .slider { background: var(--accent); border-color: var(--accent-dim); }
        input:checked + .slider::before { transform: translateX(16px); background: var(--toggle-knob-on); }

        /* ── Custom dropdowns (replaces native selects everywhere in settings) ── */
        .cdd-wrap { position: relative; display: inline-block; min-width: 190px; user-select: none; }
        .cdd-trigger {
            display: flex; align-items: center; justify-content: space-between; gap: 8px;
            background: linear-gradient(to bottom, var(--btn-g1), var(--btn-g3));
            color: var(--text-primary); border: 1px solid var(--border-accent);
            border-radius: 6px; padding: 6px 10px 6px 12px;
            font-size: 12px; font-family: inherit; cursor: pointer;
            transition: border-color .2s, background .15s; white-space: nowrap; width: 100%;
        }
        .cdd-trigger:hover { background: linear-gradient(to bottom, var(--btn-hg1), var(--btn-hg3)); border-color: var(--icon-primary); }
        .cdd-trigger.open { border-color: var(--accent-dim); border-bottom-left-radius: 0; border-bottom-right-radius: 0; }
        .cdd-trigger-left { display: flex; align-items: center; gap: 7px; overflow: hidden; }
        .cdd-trigger-text { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .cdd-trigger-dot { width: 7px; height: 7px; border-radius: 50%; background: var(--dot-off); flex-shrink: 0; transition: background .3s; }
        .cdd-trigger-dot.on { background: var(--accent); box-shadow: none; }
        .cdd-caret { width: 10px; height: 10px; stroke: var(--icon-primary); stroke-width: 2.5; fill: none; flex-shrink: 0; transition: transform .2s; }
        .cdd-trigger.open .cdd-caret { transform: rotate(180deg); }
        .cdd-panel {
            position: absolute; top: 100%; left: 0; right: 0;
            background: var(--dd-bg); border: 1px solid var(--dd-border);
            border-top: 1px solid var(--accent-dim);
            border-radius: 0 0 8px 8px;
            box-shadow: var(--shadow-panel);
            z-index: 8000; display: none; flex-direction: column; overflow: hidden;
        }
        .cdd-panel.open { display: flex; animation: cdd-in .1s ease; }
        @keyframes cdd-in { from { opacity:0; transform:translateY(-3px); } to { opacity:1; transform:translateY(0); } }
        .cdd-section-lbl { font-size: 10px; font-weight: 700; letter-spacing: .08em; text-transform: uppercase; color: var(--text-tertiary); padding: 9px 12px 3px; }
        .cdd-divider { height: 1px; background: var(--dd-border); margin: 3px 0; }
        .cdd-item {
            display: flex; align-items: center; justify-content: space-between;
            padding: 8px 12px; cursor: pointer; font-size: 12.5px; color: var(--dd-text);
            transition: background .1s;
        }
        .cdd-item:hover { background: var(--dd-hover); }
        .cdd-item.active { color: var(--accent); font-weight: 600; background: var(--bg-settings-hover); }
        .cdd-item.danger { color: var(--red); }
        .cdd-item-left { display: flex; align-items: center; gap: 8px; }
        .cdd-item-dot { width: 6px; height: 6px; border-radius: 50%; background: var(--dot-off); flex-shrink: 0; transition: background .3s; }
        .cdd-item-dot.port-open { background: var(--accent); }
        .cdd-item-badge { font-size: 10px; color: var(--text-tertiary); background: var(--badge-bg); border-radius: 3px; padding: 1px 5px; white-space: nowrap; }
        .cdd-item-badge.is-connected { color: var(--accent); }
        .cdd-item-icon { width: 13px; height: 13px; stroke: currentColor; stroke-width: 2; fill: none; flex-shrink: 0; }

        /* Status pill */
        .status-pill { display: inline-flex; align-items: center; gap: 6px; padding: 4px 11px; border-radius: 20px; font-size: 12px; font-weight: 500; background: var(--bg-tertiary); border: 1px solid var(--border-accent); color: var(--text-secondary); transition: all .3s; white-space: nowrap; }
        .status-pill .dot { width: 7px; height: 7px; border-radius: 50%; background: var(--dot-muted); flex-shrink: 0; transition: all .3s; }
        .status-pill.connected { color: var(--accent); border-color: var(--accent-dim); }
        .status-pill.connected .dot { background: var(--accent); box-shadow: none; }

        /* sbtn kept for potential future use */

        /* Theme */
        .theme-options { display: flex; flex-direction: column; gap: 10px; }
        .theme-opt { display: flex; align-items: center; justify-content: space-between; gap: 12px; padding: 12px; border: 2px solid var(--theme-border); border-radius: 8px; cursor: pointer; transition: border-color .3s, box-shadow .3s; background: var(--bg-secondary); }
        .theme-opt:hover, .theme-opt.active-theme { border-color: var(--theme-border-active); }
        .theme-opt.active-theme { box-shadow: var(--theme-glow); }
        .theme-opt-main { display: flex; align-items: center; gap: 14px; min-width: 0; }
        .theme-opt-right { display: flex; align-items: center; gap: 8px; margin-left: auto; flex-shrink: 0; }
        .theme-remove-btn { background: transparent; border: none; color: var(--text-tertiary); cursor: pointer; padding: 2px 6px; font-size: 16px; line-height: 1; border-radius: 6px; }
        .theme-remove-btn:hover { background: var(--bg-settings-hover); color: var(--text-primary); }
        .theme-preview { width: 80px; height: 50px; border-radius: 4px; margin-right: 14px; display: flex; flex-direction: column; overflow: hidden; border: 1px solid var(--border-primary); }
        .tp-dark .ph { background: #333; height: 15px; } .tp-dark .pb { background: #444; flex-grow: 1; }
        .tp-light .ph { background: #eee; height: 15px; } .tp-light .pb { background: #fff; flex-grow: 1; }
        .theme-lbl { font-size: 14px; font-weight: 500; color: var(--text-primary); }

        /* ── ACTION BAR ── */
        #action-bar { display: flex; justify-content: space-between; align-items: center; padding: 8px 12px; background: var(--bg-primary); border-top: 1px solid var(--border-secondary); }
        .ab-left { display: flex; align-items: center; }
        .ab-right { display: flex; align-items: center; gap: 7px; }
        #action-bar button { background: linear-gradient(to bottom, var(--btn-g1), var(--btn-g2), var(--btn-g3)); color: var(--text-btn); border: 1px solid var(--border-accent); border-radius: 4px; padding: 8px 14px; cursor: pointer; font-size: 12.5px; font-weight: 500; font-family: inherit; display: flex; align-items: center; justify-content: center; transition: all .2s; }
        #action-bar button:hover { background: linear-gradient(to bottom, var(--btn-hg1), var(--btn-hg2), var(--btn-hg3)); color: var(--text-btn-h); }
        #action-bar button svg { width: 16px; height: 16px; stroke: var(--icon-btn); stroke-width: 1.5; fill: none; margin-right: 7px; transition: stroke .2s; }
        #action-bar button:hover svg { stroke: var(--icon-btn-h); }

        /* Attach group */
        #attach-group { display: flex; align-items: stretch; position: relative; }
        #attach-btn { border-radius: 4px 0 0 4px !important; border-right: none !important; }
        #attach-btn.attached { border-color: var(--accent-dim) !important; color: var(--accent) !important; }
        #attach-btn.attached svg { stroke: var(--accent) !important; }
        #attach-caret { background: linear-gradient(to bottom, var(--btn-g1), var(--btn-g3)); border: 1px solid var(--border-accent); border-left: 1px solid var(--border-secondary) !important; border-radius: 0 4px 4px 0 !important; padding: 8px 9px !important; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all .2s; }
        #attach-caret:hover { background: linear-gradient(to bottom, var(--btn-hg1), var(--btn-hg3)); }
        #attach-caret.attached { border-color: var(--accent-dim) !important; }
        #attach-caret svg { width: 11px !important; height: 11px !important; margin: 0 !important; stroke: var(--icon-btn); stroke-width: 2.5; fill: none; }

        /* Dropdown */
        #attach-dd { position: absolute; bottom: calc(100% + 6px); left: 0; background: var(--dd-bg); border: 1px solid var(--dd-border); border-radius: 8px; min-width: 215px; box-shadow: var(--shadow-panel-strong); z-index: 9000; overflow: hidden; display: none; flex-direction: column; }
        #attach-dd.open { display: flex; animation: dropup .12s ease; }
        @keyframes dropup { from { opacity:0; transform:translateY(5px); } to { opacity:1; transform:translateY(0); } }
        .dd-section-lbl { font-size: 10px; font-weight: 700; letter-spacing: .08em; text-transform: uppercase; color: var(--text-tertiary); padding: 10px 12px 4px; }
        .dd-port { display: flex; align-items: center; justify-content: space-between; padding: 8px 12px; cursor: pointer; transition: background .1s; }
        .dd-port:hover { background: var(--dd-hover); }
        .dd-port-left { display: flex; align-items: center; gap: 8px; font-size: 12.5px; color: var(--dd-text); }
        .dd-port-dot { width: 6px; height: 6px; border-radius: 50%; background: var(--dot-off); flex-shrink: 0; transition: background .3s; }
        .dd-port.open .dd-port-dot { background: var(--accent); }
        .dd-port.connected-port { background: var(--conn-bg); }
        .dd-port.connected-port .dd-port-left { color: var(--accent); font-weight: 600; }
        .dd-port-badge { font-size: 10px; color: var(--text-tertiary); background: var(--bg-tertiary); border-radius: 3px; padding: 1px 5px; }
        .dd-divider { height: 1px; background: var(--dd-border); margin: 3px 0; }
        .dd-action { display: flex; align-items: center; gap: 9px; padding: 9px 12px; cursor: pointer; font-size: 12.5px; color: var(--dd-text); transition: background .1s; }
        .dd-action:hover { background: var(--dd-hover); }
        .dd-action svg { width: 14px; height: 14px; stroke: var(--icon-primary); stroke-width: 2; fill: none; flex-shrink: 0; }
        .dd-action.danger { color: var(--red); }
        .dd-action.danger svg { stroke: var(--red); }

        /* ── MODAL ── */
        .modal-overlay { position: fixed; inset: 0; background: var(--overlay-bg); display: flex; align-items: center; justify-content: center; z-index: 99999; }
        .modal-box { background: var(--bg-secondary); border: 1px solid var(--border-accent); border-radius: 10px; padding: 22px 26px; min-width: 260px; max-width: 400px; box-shadow: var(--shadow-modal); display: flex; flex-direction: column; gap: 14px; }
        .modal-box p { margin: 0; color: var(--text-primary); font-size: 13px; line-height: 1.55; }
        .modal-box button { align-self: flex-end; background: var(--bg-tertiary); color: var(--text-primary); border: 1px solid var(--border-accent); border-radius: 5px; padding: 7px 20px; cursor: pointer; font-size: 13px; font-family: inherit; }
        .modal-box button:hover { background: var(--bg-accent); }
    </style>
</head>
<body>
<div id="app-container">

    <!-- TITLE BAR -->
    <header id="app-header">
        <div class="title-bar">
            <div class="title-left-group"><span class="title">Potassium</span></div>
            <div class="top-center-actions">
                <div class="action-icon-wrapper" id="nav-editor">
                    <svg viewBox="0 0 24 24"><path d="M8 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h3"/><path d="M16 3h3a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-3"/></svg>
                </div>
                <div class="action-icon-wrapper wrench-icon" id="nav-settings">
                    <svg viewBox="0 0 24 24"><path d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z"/></svg>
                </div>
                <div class="action-icon-wrapper palette-icon" id="nav-theme">
                    <svg viewBox="0 0 24 24">
                        <circle cx="13.5" cy="6.5" r="1.5"/><circle cx="17.5" cy="10.5" r="1.5"/>
                        <circle cx="8.5" cy="7.5" r="1.5"/><circle cx="6.5" cy="12.5" r="1.5"/>
                        <path d="M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10c.926 0 1.648-.746 1.648-1.688 0-.437-.18-.835-.437-1.125-.29-.289-.438-.652-.438-1.125a1.64 1.64 0 0 1 1.668-1.668h1.996c3.051 0 5.555-2.503 5.555-5.554C21.965 6.012 17.461 2 12 2z"/>
                    </svg>
                </div>
            </div>
            <div class="title-bar-window-controls">
                <svg id="wcbtn-min" viewBox="0 0 24 24" stroke-linecap="round"><line x1="5" y1="12" x2="19" y2="12"/></svg>
                <svg id="wcbtn-max" viewBox="0 0 24 24" stroke-linecap="round"><rect x="3" y="3" width="18" height="18" rx="2"/></svg>
                <svg id="wcbtn-close" viewBox="0 0 24 24" stroke-linecap="round"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
            </div>
        </div>

        <!-- TAB BAR -->
        <div id="tab-bar">
            <div id="tabs-and-add">
                <div id="tabs-container"></div>
                <div id="tabs-scrollbar"><div id="tabs-scrollbar-thumb"></div></div>
                <button id="add-tab-btn" title="New tab">+</button>
            </div>
            <div id="tab-bar-search-container">
                <svg viewBox="0 0 24 24"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/></svg>
                <input type="text" id="tab-bar-search-input">
            </div>
        </div>
    </header>


    <!-- BODY -->
    <div id="app-body">

        <!-- Editor -->
        <div id="editor-view">
            <main id="main-editor"><div id="monaco-container"></div></main>
            <div id="right-sidebar"></div>
        </div>

        <!-- Settings -->
        <div id="settings-view">

            <p class="sec-title">Connection</p>
            <div class="sec-divider"></div>

            <div class="setting-row">
                <div class="setting-label"><span class="lbl">Status</span><span class="desc">Current connection state</span></div>
                <span class="status-pill" id="status-pill"><span class="dot"></span><span id="status-text">Disconnected</span></span>
            </div>

            <div class="setting-row">
                <div class="setting-label"><span class="lbl">Port</span><span class="desc">Target port for attachment</span></div>
                <div class="cdd-wrap" id="cdd-port">
                    <div class="cdd-trigger" id="cdd-port-trigger">
                        <div class="cdd-trigger-left">
                            <span class="cdd-trigger-dot" id="cdd-port-dot"></span>
                            <span class="cdd-trigger-text" id="cdd-port-label">Port 8392</span>
                        </div>
                        <svg class="cdd-caret" viewBox="0 0 24 24"><polyline points="6 9 12 15 18 9"/></svg>
                    </div>
                    <div class="cdd-panel" id="cdd-port-panel">
                        <div class="cdd-section-lbl">Available Ports</div>
                        <!-- populated by JS -->
                    </div>
                </div>
            </div>

            <div class="setting-row">
                <div class="setting-label"><span class="lbl">Attach</span><span class="desc">Select an action — fires immediately on pick</span></div>
                <div class="cdd-wrap" id="cdd-attach">
                    <div class="cdd-trigger" id="cdd-attach-trigger">
                        <div class="cdd-trigger-left">
                            <span class="cdd-trigger-text" id="cdd-attach-label">Attach to Selected Port</span>
                        </div>
                        <svg class="cdd-caret" viewBox="0 0 24 24"><polyline points="6 9 12 15 18 9"/></svg>
                    </div>
                    <div class="cdd-panel" id="cdd-attach-panel">
                        <div class="cdd-item" data-action="selected">
                            <div class="cdd-item-left">
                                <svg class="cdd-item-icon" viewBox="0 0 24 24"><path d="m21.44 11.05-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48"/></svg>
                                Attach to Selected Port
                            </div>
                        </div>
                        <div class="cdd-item" data-action="any">
                            <div class="cdd-item-left">
                                <svg class="cdd-item-icon" viewBox="0 0 24 24"><path d="M5 12h14"/><path d="m12 5 7 7-7 7"/></svg>
                                Attach to Any Available
                            </div>
                        </div>
                        <div class="cdd-divider"></div>
                        <div class="cdd-item danger" data-action="detach">
                            <div class="cdd-item-left">
                                <svg class="cdd-item-icon" viewBox="0 0 24 24"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
                                Detach
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="setting-row">
                <div class="setting-label"><span class="lbl">Execute To</span><span class="desc">Which port(s) receive scripts on Execute</span></div>
                <div class="cdd-wrap" id="cdd-execute">
                    <div class="cdd-trigger" id="cdd-execute-trigger">
                        <div class="cdd-trigger-left">
                            <span class="cdd-trigger-text" id="cdd-execute-label">Selected Port</span>
                        </div>
                        <svg class="cdd-caret" viewBox="0 0 24 24"><polyline points="6 9 12 15 18 9"/></svg>
                    </div>
                    <div class="cdd-panel" id="cdd-execute-panel">
                        <div class="cdd-item active" data-value="selected">
                            <div class="cdd-item-left">
                                <svg class="cdd-item-icon" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"/><polygon points="10 8 16 12 10 16 10 8" fill="currentColor" stroke="none"/></svg>
                                Selected Port
                            </div>
                        </div>
                        <div class="cdd-item" data-value="ALL">
                            <div class="cdd-item-left">
                                <svg class="cdd-item-icon" viewBox="0 0 24 24"><path d="M5 12h14"/><circle cx="19" cy="12" r="2"/><circle cx="5" cy="12" r="2"/></svg>
                                All Ports
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="setting-row">
                <div class="setting-label"><span class="lbl">Auto Attach</span><span class="desc">Reconnect automatically when Roblox opens</span></div>
                <label class="toggle-switch"><input type="checkbox" id="tog-auto-attach"><span class="slider"></span></label>
            </div>

            <p class="sec-title">Editor</p>
            <div class="sec-divider"></div>

            <div class="setting-row">
                <div class="setting-label"><span class="lbl">Minimap</span><span class="desc">Show the code minimap on the right side</span></div>
                <label class="toggle-switch"><input type="checkbox" id="tog-minimap"><span class="slider"></span></label>
            </div>

            <div class="setting-row">
                <div class="setting-label"><span class="lbl">Line Numbers</span><span class="desc">Show line numbers in the editor gutter</span></div>
                <label class="toggle-switch"><input type="checkbox" id="tog-linenums" checked><span class="slider"></span></label>
            </div>

            <div class="setting-row">
                <div class="setting-label"><span class="lbl">Smooth Typing</span><span class="desc">Adds smooth cursor/scroll animation in the editor</span></div>
                <label class="toggle-switch"><input type="checkbox" id="tog-smooth-typing" checked><span class="slider"></span></label>
            </div>

            <div class="setting-row">
                <div class="setting-label"><span class="lbl">Outline Sidebar</span><span class="desc">Show an outline of symbols in the current file</span></div>
                <label class="toggle-switch"><input type="checkbox" id="tog-outline-sidebar"><span class="slider"></span></label>
            </div>

            <div class="setting-row">
                <div class="setting-label"><span class="lbl">Auto Save Tabs</span><span class="desc">Restore your tabs automatically on next launch</span></div>
                <label class="toggle-switch"><input type="checkbox" id="tog-autosave-tabs" checked><span class="slider"></span></label>
            </div>

            <div class="setting-row">
                <div class="setting-label"><span class="lbl">Functions List</span><span class="desc">Open built-in functions.txt in a new tab</span></div>
                <button class="setting-action-btn" id="btn-open-functions">Open</button>
            </div>

            <p class="sec-title">Window</p>
            <div class="sec-divider"></div>

            <div class="setting-row">
                <div class="setting-label"><span class="lbl">Always on Top</span><span class="desc">Keep Potassium above all other windows</span></div>
                <label class="toggle-switch"><input type="checkbox" id="tog-aot"><span class="slider"></span></label>
            </div>

            <div class="setting-row">
                <div class="setting-label"><span class="lbl">Custom Theme</span><span class="desc">Create, import, and manage custom themes</span></div>
                <label class="toggle-switch"><input type="checkbox" id="tog-custom-theme"><span class="slider"></span></label>
            </div>

            <div id="custom-theme-settings" style="display:none;">
                <div class="setting-row">
                    <div class="setting-label"><span class="lbl">Template Theme</span><span class="desc">Opens a template file that explains how themes work</span></div>
                    <button class="setting-action-btn" id="btn-theme-template">Open</button>
                </div>
                <div class="setting-row">
                    <div class="setting-label"><span class="lbl">Import Theme</span><span class="desc">Import a theme JSON from your computer</span></div>
                    <button class="setting-action-btn" id="btn-theme-import">Import</button>
                </div>
                <div class="setting-row">
                    <div class="setting-label"><span class="lbl">Add Theme</span><span class="desc">Add a theme from the current tab (must be valid JSON)</span></div>
                    <button class="setting-action-btn" id="btn-theme-add">Add</button>
                </div>
                <div class="setting-row">
                    <div class="setting-label"><span class="lbl">Auto Replace</span><span class="desc">Automatically replace a theme if another theme uses the same name</span></div>
                    <label class="toggle-switch"><input type="checkbox" id="tog-theme-auto-replace"><span class="slider"></span></label>
                </div>
            </div>

            <p class="sec-title">Execution API</p>
            <div class="sec-divider"></div>

            <div class="setting-row">
            <div class="setting-label"><span class="lbl">API Backend</span><span class="desc">Choose which execution API to use (for testing)</span></div>
                <div class="cdd-wrap" id="cdd-api">
                    <div class="cdd-trigger" id="cdd-api-trigger">
                        <div class="cdd-trigger-left">
                            <span class="cdd-trigger-text" id="cdd-api-label">Rust API</span>
                        </div>
                        <svg class="cdd-caret" viewBox="0 0 24 24"><polyline points="6 9 12 15 18 9"/></svg>
                    </div>
                    <div class="cdd-panel" id="cdd-api-panel">
                        <div class="cdd-item active" data-value="rust">
                            <div class="cdd-item-left">
                                <svg class="cdd-item-icon" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
                                Rust API
                            </div>
                            <span class="cdd-item-badge">native</span>
                        </div>
                        <div class="cdd-item" data-value="js">
                            <div class="cdd-item-left">
                                <svg class="cdd-item-icon" viewBox="0 0 24 24"><polyline points="16 18 22 12 16 6"/><polyline points="8 6 2 12 8 18"/></svg>
                                JavaScript API
                            </div>
                            <span class="cdd-item-badge">node</span>
                        </div>
                    </div>
                </div>
            </div>

            <p class="sec-title">Notifications</p>
            <div class="sec-divider"></div>

            <div class="setting-row">
                <div class="setting-label"><span class="lbl">Execute Notifications</span><span class="desc">Show result modal after executing a script</span></div>
                <label class="toggle-switch"><input type="checkbox" id="tog-notif-execute" checked><span class="slider"></span></label>
            </div>

            <div class="setting-row">
                <div class="setting-label"><span class="lbl">Attach Notifications</span><span class="desc">Show modal when attaching or detaching</span></div>
                <label class="toggle-switch"><input type="checkbox" id="tog-notif-attach" checked><span class="slider"></span></label>
            </div>

        </div>

        <!-- Theme -->
        <div id="theme-view">
            <p class="sec-title">Appearance</p>
            <div class="sec-divider"></div>
            <div class="theme-options" id="theme-options"></div>
        </div>
    </div>

    <!-- ACTION BAR -->
    <footer id="action-bar">
        <div class="ab-left">
            <!-- Attach group: main button + caret for dropdown -->
            <div id="attach-group">
                <button id="attach-btn">
                    <svg viewBox="0 0 24 24"><path d="m21.44 11.05-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48"/></svg>
                    Attach
                </button>
                <button id="attach-caret">
                    <svg viewBox="0 0 24 24"><polyline points="6 9 12 15 18 9"/></svg>
                </button>

                <!-- Dropdown (opens upward) -->
                <div id="attach-dd">
                    <div class="dd-section-lbl">Ports</div>
                    <div id="dd-port-list"></div>
                    <div class="dd-divider"></div>
                    <div class="dd-action" id="dd-attach-any">
                        <svg viewBox="0 0 24 24"><path d="M5 12h14"/><path d="m12 5 7 7-7 7"/></svg>
                        Attach to Any Available
                    </div>
                    <div class="dd-action danger" id="dd-detach">
                        <svg viewBox="0 0 24 24"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
                        Detach
                    </div>
                </div>
            </div>
        </div>

        <div class="ab-right">
            <button id="btn-execute">
                <svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"/><polygon points="10 8 16 12 10 16 10 8" fill="currentColor" stroke="none"/></svg>
                Execute
            </button>
            <button id="btn-clear">
                <svg viewBox="0 0 24 24"><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/><line x1="10" y1="11" x2="10" y2="17"/><line x1="14" y1="11" x2="14" y2="17"/></svg>
                Clear
            </button>
            <button id="btn-open">
                <svg viewBox="0 0 24 24"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/></svg>
                Open
            </button>
            <button id="btn-save">
                <svg viewBox="0 0 24 24"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17 21 17 13 7 13 7 21"/><polyline points="7 3 7 8 15 8"/></svg>
                Save
            </button>
        </div>
    </footer>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.47.0/min/vs/loader.min.js"></script>
<script>
'use strict';

// ══════════════════════════════
// STATE
// ══════════════════════════════
const ALL_PORTS = ['8392','8393','8394','8395','8396','8397'];
let monacoEditor = null;
let tabs = [], activeTabId = null, tabCounter = 0;
const initialContent = '-- Potassium\n';

let connectedPort = null;
let selectedPort  = '8392';   // currently selected port in settings
let executeTarget = 'selected'; // 'selected' | 'ALL'
let attachMode    = 'selected'; // 'selected' | 'any' (controls Attach button + auto-attach behavior)
let autoAttachTimer = null;
let mainDdOpen = false;
let portStatusCache = {};   // port => true/false
let apiBackend = 'rust';    // 'rust' | 'js'
let notifExecute = true;    // show modal after execute
let notifAttach  = true;    // show modal after attach/detach
let themeName    = 'dark';  // 'dark' | 'light'
let smoothTyping = true;
let outlineSidebar = false;
let autosaveTabs = true;
let customThemeEnabled = false;
let autoReplaceThemeOnConflict = false;
let settingsApplying = false;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SETTINGS (persistence)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const SETTINGS_KEY = 'potassium.settings.v1';
const CUSTOM_THEMES_KEY = 'potassium.customThemes.v1';
const TABS_KEY = 'potassium.tabs.v1';

let customThemes = [];
let appliedCustomVarNames = [];
let saveTabsTimer = null;

function loadCustomThemes() {
    try {
        const raw = localStorage.getItem(CUSTOM_THEMES_KEY);
        if (!raw) return [];
        const parsed = JSON.parse(raw);
        if (!Array.isArray(parsed)) return [];
        return parsed.filter(t =>
            t && typeof t === 'object' &&
            typeof t.id === 'string' &&
            typeof t.name === 'string' &&
            t.vars && typeof t.vars === 'object' &&
            (t.monacoTheme == null || (t.monacoTheme && typeof t.monacoTheme === 'object'))
        );
    } catch(_) { return []; }
}
function saveCustomThemes() {
    try { localStorage.setItem(CUSTOM_THEMES_KEY, JSON.stringify(customThemes)); } catch(_) {}
}

function queueSaveTabs() {
    if (!autosaveTabs) return;
    clearTimeout(saveTabsTimer);
    saveTabsTimer = setTimeout(() => {
        saveTabsTimer = null;
        saveTabsNow();
    }, 250);
}
function saveTabsNow() {
    if (!autosaveTabs) return;
    try {
        const data = {
            version: 1,
            tabCounter,
            activeTabId,
            tabs: tabs.map(t => ({ id: t.id, name: t.name, content: t.content })),
        };
        localStorage.setItem(TABS_KEY, JSON.stringify(data));
    } catch(_) {}
}
function clearSavedTabs() {
    try { localStorage.removeItem(TABS_KEY); } catch(_) {}
}
function restoreTabsOrDefault() {
    if (autosaveTabs) {
        try {
            const raw = localStorage.getItem(TABS_KEY);
            if (raw) {
                const parsed = JSON.parse(raw);
                if (parsed && Array.isArray(parsed.tabs) && parsed.tabs.length) {
                    const restored = parsed.tabs
                        .filter(t => t && typeof t.id === 'string' && typeof t.name === 'string')
                        .map(t => ({ id: t.id, name: t.name, content: String(t.content ?? '') }));
                    if (restored.length) {
                        tabs = restored;
                        tabCounter = Number(parsed.tabCounter || restored.length) || restored.length;
                        activeTabId = typeof parsed.activeTabId === 'string' ? parsed.activeTabId : restored[0].id;
                        if (!tabs.some(t => t.id === activeTabId)) activeTabId = tabs[0].id;
                        renderTabs();
                        const active = tabs.find(t => t.id === activeTabId);
                        if (active && monacoEditor) monacoEditor.setValue(active.content || '');
                        requestAnimationFrame(syncTabsScrollbar);
                        updateOutlineSidebarDebounced();
                        return;
                    }
                }
            }
        } catch(_) {}
    }

    tabs = [];
    activeTabId = null;
    tabCounter = 0;
    addTab(null, initialContent);
}

function loadSettings() {
    try {
        const raw = localStorage.getItem(SETTINGS_KEY);
        if (!raw) return {};
        const parsed = JSON.parse(raw);
        return parsed && typeof parsed === 'object' ? parsed : {};
    } catch(_) { return {}; }
}

function saveSettings() {
    const data = {
        selectedPort,
        executeTarget,
        attachMode,
        apiBackend,
        notifExecute,
        notifAttach,
        themeName,
        smoothTyping,
        outlineSidebar,
        autosaveTabs,
        customThemeEnabled,
        autoReplaceThemeOnConflict,
        autoAttach:  !!document.getElementById('tog-auto-attach')?.checked,
        minimap:     !!document.getElementById('tog-minimap')?.checked,
        lineNums:    !!document.getElementById('tog-linenums')?.checked,
        alwaysOnTop: !!document.getElementById('tog-aot')?.checked,
    };
    try { localStorage.setItem(SETTINGS_KEY, JSON.stringify(data)); } catch(_) {}
}

function applySettings(s) {
    settingsApplying = true;
    try {
        if (s?.selectedPort && ALL_PORTS.includes(String(s.selectedPort))) selectedPort = String(s.selectedPort);
        if (s?.executeTarget === 'ALL' || s?.executeTarget === 'selected') executeTarget = s.executeTarget;
        if (s?.attachMode === 'any' || s?.attachMode === 'selected') attachMode = s.attachMode;
        if (s?.apiBackend === 'js' || s?.apiBackend === 'rust') apiBackend = s.apiBackend;
        if (typeof s?.notifExecute === 'boolean') notifExecute = s.notifExecute;
        if (typeof s?.notifAttach === 'boolean')  notifAttach  = s.notifAttach;
        if (typeof s?.themeName === 'string') themeName = s.themeName;
        if (typeof s?.smoothTyping === 'boolean') smoothTyping = s.smoothTyping;
        if (typeof s?.outlineSidebar === 'boolean') outlineSidebar = s.outlineSidebar;
        if (typeof s?.autosaveTabs === 'boolean') autosaveTabs = s.autosaveTabs;
        if (typeof s?.customThemeEnabled === 'boolean') customThemeEnabled = s.customThemeEnabled;
        if (typeof s?.autoReplaceThemeOnConflict === 'boolean') autoReplaceThemeOnConflict = s.autoReplaceThemeOnConflict;

        // Theme
        applyTheme(themeName);

        // Checkboxes
        const autoAttachEl = document.getElementById('tog-auto-attach');
        const minimapEl    = document.getElementById('tog-minimap');
        const lineNumsEl   = document.getElementById('tog-linenums');
        const smoothEl     = document.getElementById('tog-smooth-typing');
        const outlineEl    = document.getElementById('tog-outline-sidebar');
        const autosaveEl   = document.getElementById('tog-autosave-tabs');
        const aotEl        = document.getElementById('tog-aot');
        const customThemeEl = document.getElementById('tog-custom-theme');
        const customThemeSettingsEl = document.getElementById('custom-theme-settings');
        const autoReplaceEl = document.getElementById('tog-theme-auto-replace');
        const neEl         = document.getElementById('tog-notif-execute');
        const naEl         = document.getElementById('tog-notif-attach');

        if (autoAttachEl && typeof s?.autoAttach === 'boolean') autoAttachEl.checked = s.autoAttach;
        if (minimapEl    && typeof s?.minimap === 'boolean')    minimapEl.checked    = s.minimap;
        if (lineNumsEl   && typeof s?.lineNums === 'boolean')   lineNumsEl.checked   = s.lineNums;
        if (smoothEl     && typeof s?.smoothTyping === 'boolean') smoothEl.checked   = s.smoothTyping;
        if (outlineEl    && typeof s?.outlineSidebar === 'boolean') outlineEl.checked = s.outlineSidebar;
        if (autosaveEl   && typeof s?.autosaveTabs === 'boolean') autosaveEl.checked = s.autosaveTabs;
        if (aotEl        && typeof s?.alwaysOnTop === 'boolean') aotEl.checked       = s.alwaysOnTop;
        if (customThemeEl && typeof s?.customThemeEnabled === 'boolean') customThemeEl.checked = s.customThemeEnabled;
        if (autoReplaceEl && typeof s?.autoReplaceThemeOnConflict === 'boolean') autoReplaceEl.checked = s.autoReplaceThemeOnConflict;
        if (neEl) neEl.checked = !!notifExecute;
        if (naEl) naEl.checked = !!notifAttach;

        // Monaco editor options
        monacoEditor?.updateOptions({
            minimap: { enabled: !!minimapEl?.checked },
            lineNumbers: !!lineNumsEl?.checked ? 'on' : 'off',
            smoothScrolling: !!smoothEl?.checked,
            cursorBlinking: !!smoothEl?.checked ? 'smooth' : 'blink',
            cursorSmoothCaretAnimation: !!smoothEl?.checked ? 'on' : 'off',
        });
        smoothTyping = !!smoothEl?.checked;
        outlineSidebar = !!outlineEl?.checked;
        autosaveTabs = !!autosaveEl?.checked;
        customThemeEnabled = !!customThemeEl?.checked;
        autoReplaceThemeOnConflict = !!autoReplaceEl?.checked;
        if (customThemeSettingsEl) customThemeSettingsEl.style.display = customThemeEnabled ? 'block' : 'none';
        updateOutlineSidebar();
        renderThemeOptions();

        // Always on top (best-effort)
        tauriInvoke('set_always_on_top', { value: !!aotEl?.checked }).catch(() => {});

        // Execute CDD label + active state
        const execLabel = document.getElementById('cdd-execute-label');
        if (execLabel) execLabel.textContent = executeTarget === 'ALL' ? 'All Ports' : 'Selected Port';
        document.querySelectorAll('#cdd-execute-panel .cdd-item').forEach(el => {
            el.classList.toggle('active', el.dataset.value === executeTarget);
        });

        // API CDD label + active state
        const apiLabel = document.getElementById('cdd-api-label');
        if (apiLabel) apiLabel.textContent = apiBackend === 'js' ? 'JavaScript API' : 'Rust API';
        document.querySelectorAll('#cdd-api-panel .cdd-item').forEach(el => {
            el.classList.toggle('active', el.dataset.value === apiBackend);
        });

        // Attach CDD label + active state
        const attachLabel = document.getElementById('cdd-attach-label');
        if (attachLabel) attachLabel.textContent = attachMode === 'any' ? 'Attach to Any Available' : 'Attach to Selected Port';
        document.querySelectorAll('#cdd-attach-panel .cdd-item').forEach(el => {
            const action = el.dataset.action;
            el.classList.toggle('active', (action === 'selected' && attachMode === 'selected') || (action === 'any' && attachMode === 'any'));
        });

        // Port CDD
        renderPortCddPanel();
        refreshPortCddTrigger();

        // Auto-attach
        if (autoAttachEl?.checked) startAutoAttach(true);
        else stopAutoAttach();
    } finally {
        settingsApplying = false;
    }
}

// ══════════════════════════════
// TAURI
// ══════════════════════════════
function tauriInvoke(cmd, args) {
    const fn = window.__TAURI__?.core?.invoke
            ?? window.__TAURI__?.tauri?.invoke
            ?? window.__TAURI__?.invoke;
    if (!fn) return Promise.reject('Tauri not available — check window.__TAURI__');
    console.log('[Tauri invoke]', cmd, JSON.stringify(args ?? {}));
    return fn(cmd, args ?? {});
}

// ══════════════════════════════════════════════════════════════
// JS API — pure JavaScript implementation using Node net + zlib
// Exposed via Tauri's invoke bridge to js_api_call command.
// All attach / detach / execute / check_port operations route
// through here when apiBackend === 'js'.
// ══════════════════════════════════════════════════════════════

// Low-level: send one operation through the Rust js_api_call bridge
// which runs the actual Node net+zlib logic server-side.
// Command signature: js_api_call(op: String, code: String, port: String) -> String
async function jsApiBridge(op, code, port) {
    try {
        return await tauriInvoke('js_api_call', { op, code, port });
    } catch(e) {
        console.warn('[JS API] bridge error, falling back to Rust API:', e);
        // Fallback to matching Rust command
        if (op === 'execute') return await tauriInvoke('OpiumwareExecution', { code, port });
        if (op === 'attach')  return await tauriInvoke('OpiumwareAttach');
        if (op === 'detach')  return await tauriInvoke('OpiumwareDetach', { port });
        if (op === 'check')   return await tauriInvoke('check_port', { port });
        return 'Error: unknown op ' + op;
    }
}

// JS API — execute script on port(s)
async function jsApiExecute(code, port) {
    return await jsApiBridge('execute', code, port);
}

// JS API — attach: scan all ports, return first reachable
async function jsApiAttach() {
    return await jsApiBridge('attach', 'NULL', 'ALL');
}

// JS API — attach to specific port (probe with NULL script)
async function jsApiAttachToPort(port) {
    return await jsApiBridge('execute', 'NULL', port);
}

// JS API — detach (just ends logical connection, no data sent)
async function jsApiDetach(port) {
    return await jsApiBridge('detach', '', port);
}

// JS API — check if a port is open
async function jsApiCheckPort(port) {
    const result = await jsApiBridge('check', '', port);
    return result === 'true' || result === true;
}

// ══════════════════════════════
// MODAL
// ══════════════════════════════
function modal(msg) {
    document.querySelector('.modal-overlay')?.remove();
    const ov = document.createElement('div'); ov.className = 'modal-overlay';
    const box = document.createElement('div'); box.className = 'modal-box';
    const p = document.createElement('p'); p.textContent = msg;
    const btn = document.createElement('button'); btn.textContent = 'OK';
    btn.onclick = () => ov.remove();
    ov.onclick = e => { if (e.target === ov) ov.remove(); };
    box.append(p, btn); ov.appendChild(box);
    document.body.appendChild(ov); btn.focus();
}

// SCRIPT NORMALIZATION
function toOpiumwarePacket(editorCode) {
    const code = String(editorCode ?? '').trim();
    if (!code) return '';
    if (code === 'NULL') return 'NULL';
    if (/^Opiumware(?:Script|Setting)\b/.test(code)) return code;
    return 'OpiumwareScript ' + code;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FUNCTIONS.TXT â€” completions + hover docs (best-effort)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let functionsTxtCache = null;
let functionNames = [];
let functionDocs = new Map(); // name -> doc string
let functionProvidersRegistered = false;

async function fetchFunctionsTxt() {
    if (functionsTxtCache != null) return functionsTxtCache;
    try {
        const res = await fetch('functions.txt', { cache: 'no-store' });
        if (!res.ok) throw new Error('HTTP ' + res.status);
        functionsTxtCache = await res.text();
        return functionsTxtCache;
    } catch (e) {
        console.warn('[functions.txt] load failed:', e);
        functionsTxtCache = '';
        return '';
    }
}

function parseFunctionsTxt(text) {
    const names = [];
    const docs = new Map();

    const lines = String(text ?? '').split(/\\r?\\n/);
    for (const raw of lines) {
        const line = raw.trim();
        if (!line) continue;
        if (line.startsWith('#') || line.startsWith('//')) continue;

        // Supported formats (optional docs):
        //   name
        //   name - description
        //   name: description
        //   name|description
        const m = line.match(/^([A-Za-z_][A-Za-z0-9_\\.]*)\\s*(?:[-:|]\\s*(.+))?$/);
        if (!m) continue;
        const name = m[1];
        const doc = (m[2] || '').trim();

        names.push(name);
        if (doc) docs.set(name, doc);
    }

    const uniq = [...new Set(names)].sort((a, b) => a.localeCompare(b));
    return { names: uniq, docs };
}

async function ensureFunctionsIndexLoaded() {
    if (functionNames.length) return;
    const text = await fetchFunctionsTxt();
    const parsed = parseFunctionsTxt(text);
    functionNames = parsed.names;
    functionDocs = parsed.docs;
}

function registerFunctionsIntellisense() {
    if (functionProvidersRegistered) return;
    if (!window.monaco) return;

    functionProvidersRegistered = true;

    monaco.languages.registerCompletionItemProvider('lua', {
        triggerCharacters: ['_', '.'],
        provideCompletionItems: async (model, position) => {
            await ensureFunctionsIndexLoaded();

            const word = model.getWordUntilPosition(position);
            const query = (word?.word || '').toLowerCase();
            const range = new monaco.Range(position.lineNumber, word.startColumn, position.lineNumber, word.endColumn);

            let matches = functionNames;
            if (query) matches = functionNames.filter(n => n.toLowerCase().includes(query));

            if (!query) matches = matches.slice(0, 200);
            else matches = matches.slice(0, 400);

            const suggestions = matches.map(name => {
                const doc = functionDocs.get(name) || 'No documentation found in functions.txt for this item.';
                return {
                    label: name,
                    kind: monaco.languages.CompletionItemKind.Function,
                    insertText: name,
                    range,
                    detail: 'functions.txt',
                    documentation: { value: `**${name}**\\n\\n${doc}` },
                };
            });

            return { suggestions };
        },
    });

    monaco.languages.registerHoverProvider('lua', {
        provideHover: async (model, position) => {
            await ensureFunctionsIndexLoaded();
            const w = model.getWordAtPosition(position);
            if (!w?.word) return null;

            const name = w.word;
            if (!functionNames.includes(name)) return null;

            const doc = functionDocs.get(name) || 'No documentation found in functions.txt for this item.';
            return {
                range: new monaco.Range(position.lineNumber, w.startColumn, position.lineNumber, w.endColumn),
                contents: [{ value: `**${name}**\\n\\n${doc}` }],
            };
        },
    });
}

// ══════════════════════════════
// CONNECTION STATE
// ══════════════════════════════
// OUTLINE SIDEBAR (best-effort Lua outline)
let rightSidebarEl = null;
let outlineUpdateRaf = 0;
let outlineHeaderEl = null;
let outlineListEl = null;
let outlineSearchQuery = '';

function updateOutlineSidebarDebounced() {
    if (!outlineSidebar) return;
    if (outlineUpdateRaf) cancelAnimationFrame(outlineUpdateRaf);
    outlineUpdateRaf = requestAnimationFrame(() => {
        outlineUpdateRaf = 0;
        updateOutlineSidebar();
    });
}

function confirmModal(msg, confirmText = 'Confirm', denyText = 'Cancel') {
    return new Promise(resolve => {
        document.querySelector('.modal-overlay')?.remove();
        const ov = document.createElement('div'); ov.className = 'modal-overlay';
        const box = document.createElement('div'); box.className = 'modal-box';
        const p = document.createElement('p'); p.textContent = msg;

        const row = document.createElement('div');
        row.style.display = 'flex';
        row.style.gap = '8px';
        row.style.justifyContent = 'flex-end';

        const deny = document.createElement('button'); deny.textContent = denyText;
        const ok = document.createElement('button'); ok.textContent = confirmText;

        const close = (val) => { ov.remove(); resolve(val); };
        deny.onclick = () => close(false);
        ok.onclick = () => close(true);

        ov.onclick = e => { if (e.target === ov) close(false); };
        document.addEventListener('keydown', function onKey(e) {
            if (e.key === 'Escape') { document.removeEventListener('keydown', onKey); close(false); }
        });

        row.append(deny, ok);
        box.append(p, row);
        ov.appendChild(box);
        document.body.appendChild(ov);
        ok.focus();
    });
}

function clearOutlineSidebarUi() {
    outlineHeaderEl = null;
    outlineListEl = null;
    if (rightSidebarEl) rightSidebarEl.innerHTML = '';
}

function ensureOutlineSidebarUi() {
    if (!rightSidebarEl) return;
    if (outlineHeaderEl && outlineListEl) return;

    rightSidebarEl.innerHTML = '';

    outlineHeaderEl = document.createElement('div');
    outlineHeaderEl.className = 'outline-header';
    outlineHeaderEl.textContent = 'Outline View';
    rightSidebarEl.appendChild(outlineHeaderEl);

    outlineListEl = document.createElement('div');
    outlineListEl.className = 'outline-list';
    rightSidebarEl.appendChild(outlineListEl);
}

function functionKind(name) {
    const raw = String(name || '');
    const lower = raw.toLowerCase();
    const last = lower.split(/[.:]/).filter(Boolean).pop() || lower;
    if (raw.includes(':')) return 'method';
    if (last === 'new' || last === 'init' || last === 'constructor') return 'ctor';
    return 'fn';
}

function classifyLiteral(rhsRaw) {
    const rhs = String(rhsRaw || '').trim();
    if (!rhs) return null;
    if (rhs.startsWith('"') || rhs.startsWith("'")) return 'str';
    if (/^-?\d+(?:\.\d+)?\b/.test(rhs)) return 'num';
    if (/^(?:true|false)\b/i.test(rhs)) return 'bool';
    if (rhs.startsWith('{')) {
        const after = rhs.slice(1).trimStart();
        if (!after || after.startsWith('}')) return 'obj';
        if (after.startsWith('[')) return 'obj';
        if (/^[A-Za-z_][A-Za-z0-9_]*\s*=/.test(after)) return 'obj';
        return 'arr';
    }
    return null;
}

function classifyTableSnippet(name, snippet, classHints) {
    const rawName = String(name || '');
    const short = rawName.split('.').pop() || rawName;

    if (rawName.includes('.')) return 'namespace';
    if (/^I[A-Z]/.test(short) && !classHints.has(short)) return 'interface';
    if (/enum$/i.test(short) || /\bENUM\b/.test(rawName)) return 'enum';
    if (/module/i.test(rawName)) return 'module';
    if (classHints.has(short)) return 'class';

    const upperKeys = (snippet.match(/\b([A-Z][A-Z0-9_]*)\s*=/g) || []).length;
    if (upperKeys >= 3) return 'enum';

    const m = snippet.match(/=\s*{\s*([\s\S]{0,60})/);
    const after = ((m && m[1]) || '').trimStart();
    if (!after || after.startsWith('}')) return 'obj';
    if (after.startsWith('[')) return 'obj';
    if (/^[A-Za-z_][A-Za-z0-9_]*\s*=/.test(after)) return 'obj';
    return 'arr';
}

function outlineIconSvg(kind) {
    // Inline Lucide-style icons (no external runtime needed).
    const common = 'viewBox="0 0 24 24" width="14" height="14" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"';
    switch (kind) {
        case 'fn':
        case 'method':
        case 'ctor':
            return `<svg ${common}><polyline points="16 18 22 12 16 6"></polyline><polyline points="8 6 2 12 8 18"></polyline></svg>`; // code
        case 'class':
            return `<svg ${common}><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline><line x1="12" y1="22.08" x2="12" y2="12"></line></svg>`; // box
        case 'interface':
            return `<svg ${common}><polygon points="12 2 2 7 12 12 22 7 12 2"></polygon><polyline points="2 17 12 22 22 17"></polyline><polyline points="2 12 12 17 22 12"></polyline></svg>`; // layers
        case 'namespace':
        case 'module':
            return `<svg ${common}><path d="M3 7h6l2 2h10v10a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V7z"></path></svg>`; // folder
        case 'enum':
            return `<svg ${common}><line x1="8" y1="6" x2="21" y2="6"></line><line x1="8" y1="12" x2="21" y2="12"></line><line x1="8" y1="18" x2="21" y2="18"></line><line x1="3" y1="6" x2="3.01" y2="6"></line><line x1="3" y1="12" x2="3.01" y2="12"></line><line x1="3" y1="18" x2="3.01" y2="18"></line></svg>`; // list
        case 'const':
            return `<svg ${common}><path d="M20.59 13.41 11 3H4v7l9.59 9.59a2 2 0 0 0 2.82 0l4.18-4.18a2 2 0 0 0 0-2.82z"></path><line x1="7" y1="7" x2="7.01" y2="7"></line></svg>`; // tag
        case 'var':
        case 'prop':
        case 'field':
            return `<svg ${common}><circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="2"></circle></svg>`; // circle-dot
        case 'str':
            return `<svg ${common}><polyline points="4 7 4 4 20 4 20 7"></polyline><line x1="9" y1="20" x2="15" y2="20"></line><line x1="12" y1="4" x2="12" y2="20"></line></svg>`; // type
        case 'num':
            return `<svg ${common}><line x1="4" y1="9" x2="20" y2="9"></line><line x1="4" y1="15" x2="20" y2="15"></line><line x1="10" y1="3" x2="8" y2="21"></line><line x1="16" y1="3" x2="14" y2="21"></line></svg>`; // hash
        case 'bool':
            return `<svg ${common}><rect x="1" y="5" width="22" height="14" rx="7" ry="7"></rect><circle cx="8" cy="12" r="3"></circle></svg>`; // toggle-left
        case 'arr':
            return `<svg ${common}><path d="M8 4H6a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h2"></path><path d="M16 4h2a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2h-2"></path></svg>`; // brackets
        case 'obj':
            return `<svg ${common}><path d="M8 3H7a2 2 0 0 0-2 2v4a2 2 0 0 1-2 2 2 2 0 0 1 2 2v4a2 2 0 0 0 2 2h1"></path><path d="M16 21h1a2 2 0 0 0 2-2v-4a2 2 0 0 1 2-2 2 2 0 0 1-2-2V5a2 2 0 0 0-2-2h-1"></path></svg>`; // braces
        default:
            return `<svg ${common}><circle cx="12" cy="12" r="1"></circle></svg>`;
    }
}

function outlineGroupIconSvg(groupTitle) {
    switch (groupTitle) {
        case 'Structural Elements': return outlineIconSvg('module');
        case 'Data Elements': return outlineIconSvg('enum');
        case 'Logic Elements': return outlineIconSvg('fn');
        case 'Values': return outlineIconSvg('obj');
        default: return outlineIconSvg('node');
    }
}

function parseLuaOutline(model) {
    const text = model.getValue();
    const items = [];
    const add = (name, kind, idx, offset = 0) => {
        try {
            const pos = model.getPositionAt(idx + offset);
            items.push({ name, kind, pos });
        } catch(_) {}
    };

    const seen = new Set();

    // Pre-scan for class hints
    const classHints = new Set();
    const idxRe = /^\s*([A-Za-z_][A-Za-z0-9_]*)\.__index\s*=\s*\1\b/gm;
    let ix;
    while ((ix = idxRe.exec(text)) !== null) classHints.add(ix[1]);
    const smRe = /\bsetmetatable\s*\(\s*[^,]+,\s*([A-Za-z_][A-Za-z0-9_]*)\s*\)/gm;
    let sm;
    while ((sm = smRe.exec(text)) !== null) classHints.add(sm[1]);

    // Logic elements: functions / methods / ctors
    const fnDecl = /^\s*(?:local\s+)?function\s+([A-Za-z_][A-Za-z0-9_:.]*)\s*\(/gm;
    const fnAssign = /^\s*(?:local\s+)?([A-Za-z_][A-Za-z0-9_:.]*)\s*=\s*function\s*\(/gm;
    for (const re of [fnDecl, fnAssign]) {
        let m;
        while ((m = re.exec(text)) !== null) {
            const name = m[1];
            if (!name || seen.has(name)) continue;
            seen.add(name);
            add(name, functionKind(name), m.index, m[0].indexOf(name));
        }
    }

    // Structural: modules
    const reqAssign = /^\s*(?:local\s+)?([A-Za-z_][A-Za-z0-9_]*)\s*=\s*require\s*\(/gm;
    let rq;
    while ((rq = reqAssign.exec(text)) !== null) {
        const name = rq[1];
        if (!name || seen.has(name)) continue;
        seen.add(name);
        add(name, 'module', rq.index, rq[0].indexOf(name));
    }

    // Structural: tables (namespaces / classes / enums / objects / arrays)
    const tableAssign = /^\s*(?:local\s+)?([A-Za-z_][A-Za-z0-9_:.]*)\s*=\s*{\s*/gm;
    let ta;
    while ((ta = tableAssign.exec(text)) !== null) {
        const name = ta[1];
        if (!name || seen.has(name)) continue;
        const snippet = text.slice(ta.index, Math.min(text.length, ta.index + 700));
        const kind = classifyTableSnippet(name, snippet, classHints);
        seen.add(name);
        add(name, kind, ta.index, ta[0].indexOf(name));
    }

    // Values: local literals
    const localValue = /^\s*local\s+([A-Za-z_][A-Za-z0-9_]*)\s*=\s*([^\r\n]+)/gm;
    let vm;
    while ((vm = localValue.exec(text)) !== null) {
        const name = vm[1];
        const rhs = vm[2];
        if (!name || seen.has(name)) continue;
        const lit = classifyLiteral(rhs);
        if (!lit) continue;
        const isConstName = /^[A-Z0-9_]+$/.test(name);
        seen.add(name);
        add(name, isConstName ? 'const' : lit, vm.index, vm[0].indexOf(name));
    }

    // Data: local decls (variables / constants)
    const localDecl = /^\s*local\s+([A-Za-z_][A-Za-z0-9_]*(?:\s*,\s*[A-Za-z_][A-Za-z0-9_]*)*)/gm;
    let lm;
    while ((lm = localDecl.exec(text)) !== null) {
        const parts = lm[1].split(',').map(s => s.trim()).filter(Boolean);
        for (const p of parts) {
            if (!p || seen.has(p)) continue;
            seen.add(p);
            const kind = /^[A-Z0-9_]+$/.test(p) ? 'const' : 'var';
            add(p, kind, lm.index, lm[0].indexOf(p));
        }
    }

    // Data: properties / fields (dotted assigns)
    const propAssign = /^\s*([A-Za-z_][A-Za-z0-9_]*(?:\.[A-Za-z_][A-Za-z0-9_]*)+)\s*=\s*(?!function\b)/gm;
    let pm;
    while ((pm = propAssign.exec(text)) !== null) {
        const name = pm[1];
        if (!name || seen.has(name)) continue;
        seen.add(name);
        add(name, 'prop', pm.index, pm[0].indexOf(name));
    }

    items.sort((a, b) => (a.pos.lineNumber - b.pos.lineNumber) || (a.pos.column - b.pos.column));
    return items;
}

function buildNameTree(items) {
    const root = { children: new Map(), item: null, order: Number.POSITIVE_INFINITY };
    const splitName = (name) => name.replace(/:/g, '.').split('.').filter(Boolean);

    for (const it of items) {
        const order = (it?.pos?.lineNumber || 0) * 1000000 + (it?.pos?.column || 0);
        const parts = splitName(it.name);
        let node = root;
        if (order < node.order) node.order = order;
        for (const part of parts) {
            if (!node.children.has(part)) node.children.set(part, { children: new Map(), item: null, key: part, order: Number.POSITIVE_INFINITY });
            node = node.children.get(part);
            if (order < node.order) node.order = order;
        }
        node.item = it;
    }

    return root;
}

function renderTree(listEl, node, depth = 0) {
    const children = [...node.children.entries()]
        .sort((a, b) => (a[1].order - b[1].order) || a[0].localeCompare(b[0]));
    for (const [key, child] of children) {

        const row = document.createElement('div');
        row.className = 'outline-item';

        const indent = document.createElement('span');
        indent.className = 'outline-indent';
        indent.style.marginLeft = (depth * 10) + 'px';

        const kind = document.createElement('span');
        kind.className = 'outline-kind k-' + (child.item?.kind || 'node');
        kind.innerHTML = outlineIconSvg(child.item?.kind || 'node');

        const label = document.createElement('span');
        label.textContent = key;

        row.append(indent, kind, label);

        if (child.item) {
            row.addEventListener('click', () => {
                if (!monacoEditor) return;
                monacoEditor.setPosition(child.item.pos);
                const scrollType = (window.monaco && window.monaco.editor && window.monaco.editor.ScrollType && window.monaco.editor.ScrollType.Smooth) || undefined;
                monacoEditor.revealPositionInCenter(child.item.pos, scrollType);
                monacoEditor.focus();
            });
        } else {
            row.style.opacity = '0.85';
            row.style.cursor = 'default';
        }

        listEl.appendChild(row);
        renderTree(listEl, child, depth + 1);
    }
}

function updateOutlineSidebar() {
    if (!rightSidebarEl) return;
    const searchEl = document.getElementById('tab-bar-search-input');
    if (searchEl) searchEl.placeholder = outlineSidebar ? 'Search outline…' : '';

    if (!outlineSidebar) { clearOutlineSidebarUi(); return; }
    ensureOutlineSidebarUi();

    // Search uses the existing top search bar (no dedicated outline search box)
    outlineSearchQuery = document.getElementById('tab-bar-search-input')?.value || '';

    const model = monacoEditor?.getModel();
    if (!model) return;

    const all = parseLuaOutline(model);
    const q = String(outlineSearchQuery || '').trim().toLowerCase();
    const items = q ? all.filter(it => String(it.name).toLowerCase().includes(q)) : all;

    outlineListEl.innerHTML = '';

    if (!items.length) {
        const empty = document.createElement('div');
        empty.className = 'outline-empty';
        empty.textContent = q ? 'No matches.' : 'No symbols found.';
        outlineListEl.appendChild(empty);
        return;
    }

    const structural = items.filter(i => ['class','interface','namespace','module'].includes(i.kind));
    const data = items.filter(i => ['var','const','prop','field','enum'].includes(i.kind));
    const logic = items.filter(i => ['fn','method','ctor'].includes(i.kind));
    const values = items.filter(i => ['str','num','bool','arr','obj'].includes(i.kind));

    const addGroup = (title, groupItems) => {
        if (!groupItems.length) return;
        const gl = document.createElement('div');
        gl.className = 'outline-group';
        const icon = document.createElement('span');
        icon.className = 'outline-group-icon';
        icon.innerHTML = outlineGroupIconSvg(title);
        gl.append(icon, document.createTextNode(title));
        outlineListEl.appendChild(gl);
        renderTree(outlineListEl, buildNameTree(groupItems), 0);
    };

    addGroup('Structural Elements', structural);
    addGroup('Data Elements', data);
    addGroup('Logic Elements', logic);
    addGroup('Values', values);

}

function setConnectedPort(port) {
    connectedPort = port;
    const pill = document.getElementById('status-pill');
    const text = document.getElementById('status-text');
    if (port) {
        pill?.classList.add('connected');
        if (text) text.textContent = 'Port ' + port;
        selectedPort = port;
    } else {
        pill?.classList.remove('connected');
        if (text) text.textContent = 'Disconnected';
    }
    document.getElementById('attach-btn')?.classList.toggle('attached', !!port);
    document.getElementById('attach-caret')?.classList.toggle('attached', !!port);
    refreshPortCddTrigger();
    renderMainDdPorts();
    renderPortCddPanel();
    if (!settingsApplying) saveSettings();
}

// ══════════════════════════════
// ATTACH LOGIC
// ══════════════════════════════
async function attachToPort(port, silent = false) {
    try {
        const result = apiBackend === 'js'
            ? await jsApiAttachToPort(port)
            : await tauriInvoke('OpiumwareExecution', { code: 'NULL', port });
        if (result?.toLowerCase().includes('success')) {
            setConnectedPort(port);
            if (!silent && notifAttach) modal('Attached to port ' + port);
            return true;
        }
        setConnectedPort(null);
        if (!silent && notifAttach) modal(result || 'Failed to connect to port ' + port);
        return false;
    } catch(e) {
        setConnectedPort(null);
        if (!silent && notifAttach) modal('Attach error: ' + e);
        return false;
    }
}

async function attachToAny(silent = false) {
    try {
        const result = apiBackend === 'js'
            ? await jsApiAttach()
            : await tauriInvoke('OpiumwareAttach');
        if (result?.toLowerCase().includes('success')) {
            const m = result.match(/port[:\s]+(\d+)/i);
            setConnectedPort(m ? m[1] : ALL_PORTS[0]);
            if (!silent && notifAttach) modal(result);
            return true;
        }
        setConnectedPort(null);
        if (!silent && notifAttach) modal(result || 'No available port found.');
        return false;
    } catch(e) {
        setConnectedPort(null);
        if (!silent && notifAttach) modal('Attach error: ' + e);
        return false;
    }
}

async function detach() {
    if (connectedPort) {
        try {
            if (apiBackend === 'js') {
                await jsApiDetach(connectedPort);
            } else {
                await tauriInvoke('OpiumwareDetach', { port: connectedPort });
            }
        } catch(_) {}
    }
    setConnectedPort(null);
}

// ══════════════════════════════
// AUTO ATTACH
// ══════════════════════════════
function startAutoAttach(silent = false) {
    if (autoAttachTimer) return;

    // Try once immediately, then keep retrying.
    if (!connectedPort) {
        if (attachMode === 'any') attachToAny(true);
        else attachToPort(selectedPort, true);
    }

    autoAttachTimer = setInterval(() => {
        if (connectedPort) return;
        if (attachMode === 'any') attachToAny(true);
        else attachToPort(selectedPort, true);
    }, 3000);

    if (!silent && notifAttach) modal('Auto attach enabled.');
}
function stopAutoAttach() { clearInterval(autoAttachTimer); autoAttachTimer = null; }

// ══════════════════════════════
// PORT SCAN
// ══════════════════════════════
async function scanPorts() {
    await Promise.allSettled(ALL_PORTS.map(async p => {
        try {
            if (apiBackend === 'js') {
                portStatusCache[p] = await jsApiCheckPort(p);
            } else {
                portStatusCache[p] = !!(await tauriInvoke('check_port', { port: p }));
            }
        } catch(_) { portStatusCache[p] = false; }
    }));
    renderMainDdPorts();
    renderPortCddPanel();
    refreshPortCddTrigger();
}

// ══════════════════════════════
// MAIN ACTION BAR DROPDOWN (attach-dd)
// ══════════════════════════════
function renderMainDdPorts() {
    const list = document.getElementById('dd-port-list');
    if (!list) return;
    list.innerHTML = '';
    ALL_PORTS.forEach(p => {
        const isOpen = portStatusCache[p] ?? false;
        const isConn = connectedPort === p;
        const item = document.createElement('div');
        item.className = 'dd-port' + (isOpen ? ' open' : '') + (isConn ? ' connected-port' : '');
        const dot = document.createElement('span'); dot.className = 'dd-port-dot';
        const lbl = document.createElement('span'); lbl.className = 'dd-port-left';
        lbl.append(dot, document.createTextNode('Port ' + p));
        const badge = document.createElement('span'); badge.className = 'dd-port-badge';
        badge.textContent = isConn ? 'connected' : (isOpen ? 'open' : 'closed');
        item.append(lbl, badge);
        item.addEventListener('click', async () => { closeMainDd(); await attachToPort(p); });
        list.appendChild(item);
    });
}

function openMainDd()  { document.getElementById('attach-dd').classList.add('open'); mainDdOpen = true; scanPorts(); }
function closeMainDd() { document.getElementById('attach-dd').classList.remove('open'); mainDdOpen = false; }
function toggleMainDd() { mainDdOpen ? closeMainDd() : openMainDd(); }

// ══════════════════════════════
// CUSTOM DROPDOWN HELPER
// ══════════════════════════════
// Tracks which cdd panels are open so we can close others
const openCdds = new Set();

function openCdd(panelId, triggerId) {
    // Close all other cdds first
    openCdds.forEach(id => {
        if (id !== panelId) {
            document.getElementById(id)?.classList.remove('open');
            document.getElementById(id.replace('-panel','-trigger'))?.classList.remove('open');
            openCdds.delete(id);
        }
    });
    document.getElementById(panelId)?.classList.add('open');
    document.getElementById(triggerId)?.classList.add('open');
    openCdds.add(panelId);
}
function closeCdd(panelId, triggerId) {
    document.getElementById(panelId)?.classList.remove('open');
    document.getElementById(triggerId)?.classList.remove('open');
    openCdds.delete(panelId);
}
function toggleCdd(panelId, triggerId) {
    if (openCdds.has(panelId)) closeCdd(panelId, triggerId);
    else openCdd(panelId, triggerId);
}

// Close all cdds on outside click
document.addEventListener('click', e => {
    // Close main dropdown
    if (mainDdOpen && !document.getElementById('attach-group')?.contains(e.target)) closeMainDd();
    // Close all custom dropdowns
    [...openCdds].forEach(panelId => {
        const trigger = document.getElementById(panelId.replace('-panel','-trigger'));
        const panel = document.getElementById(panelId);
        if (!panel?.contains(e.target) && !trigger?.contains(e.target)) {
            closeCdd(panelId, panelId.replace('-panel','-trigger'));
        }
    });
});

// ══════════════════════════════
// PORT CDD (settings port picker)
// ══════════════════════════════
function renderPortCddPanel() {
    const panel = document.getElementById('cdd-port-panel');
    if (!panel) return;
    // Keep the section label, rebuild items after it
    const sectionLbl = panel.querySelector('.cdd-section-lbl');
    // Remove all items
    panel.querySelectorAll('.cdd-item, .cdd-divider').forEach(el => el.remove());

    ALL_PORTS.forEach(p => {
        const isOpen = portStatusCache[p] ?? false;
        const isConn = connectedPort === p;
        const isSel  = selectedPort === p;

        const item = document.createElement('div');
        item.className = 'cdd-item' + (isSel ? ' active' : '');

        const dot = document.createElement('span');
        dot.className = 'cdd-item-dot' + (isOpen || isConn ? ' port-open' : '');

        const left = document.createElement('div'); left.className = 'cdd-item-left';
        left.append(dot, document.createTextNode('Port ' + p));

        const badge = document.createElement('span');
        badge.className = 'cdd-item-badge' + (isConn ? ' is-connected' : '');
        badge.textContent = isConn ? 'connected' : (isOpen ? 'open' : 'closed');

        item.append(left, badge);
        item.addEventListener('click', () => {
            selectedPort = p;
            closeCdd('cdd-port-panel', 'cdd-port-trigger');
            refreshPortCddTrigger();
            renderPortCddPanel();
            if (!settingsApplying) saveSettings();
        });
        panel.appendChild(item);
    });
}

function refreshPortCddTrigger() {
    const label = document.getElementById('cdd-port-label');
    const dot   = document.getElementById('cdd-port-dot');
    if (label) label.textContent = 'Port ' + selectedPort;
    if (dot) {
        const isConn = connectedPort === selectedPort;
        const isOpen = portStatusCache[selectedPort] ?? false;
        dot.className = 'cdd-trigger-dot' + (isConn || isOpen ? ' on' : '');
    }
}

// ══════════════════════════════
// EXECUTE CDD
// ══════════════════════════════
function setupExecuteCdd() {
    const panel = document.getElementById('cdd-execute-panel');
    panel?.querySelectorAll('.cdd-item').forEach(item => {
        item.addEventListener('click', () => {
            executeTarget = item.dataset.value;
            document.getElementById('cdd-execute-label').textContent = item.querySelector('.cdd-item-left').textContent.trim();
            panel.querySelectorAll('.cdd-item').forEach(i => i.classList.remove('active'));
            item.classList.add('active');
            closeCdd('cdd-execute-panel', 'cdd-execute-trigger');
            if (!settingsApplying) saveSettings();
        });
    });
}

// ══════════════════════════════
// ATTACH CDD (settings)
// ══════════════════════════════
function setupAttachCdd() {
    const panel = document.getElementById('cdd-attach-panel');
    panel?.querySelectorAll('.cdd-item').forEach(item => {
        item.addEventListener('click', async () => {
            const action = item.dataset.action;
            const labelEl = document.getElementById('cdd-attach-label');
            closeCdd('cdd-attach-panel', 'cdd-attach-trigger');

            if (action === 'selected') {
                attachMode = 'selected';
                if (labelEl) labelEl.textContent = item.querySelector('.cdd-item-left').textContent.trim();
                panel.querySelectorAll('.cdd-item').forEach(i => i.classList.remove('active'));
                item.classList.add('active');
                if (!settingsApplying) saveSettings();
                await attachToPort(selectedPort);
            } else if (action === 'any') {
                attachMode = 'any';
                if (labelEl) labelEl.textContent = item.querySelector('.cdd-item-left').textContent.trim();
                panel.querySelectorAll('.cdd-item').forEach(i => i.classList.remove('active'));
                item.classList.add('active');
                if (!settingsApplying) saveSettings();
                await attachToAny(false);
            } else if (action === 'detach') {
                await detach();
                modal('Detached.');
            }
        });
    });
}

// ══════════════════════════════
// TABS
// ══════════════════════════════
const tabsContainer = document.getElementById('tabs-container');
const tabsScrollbar = document.getElementById('tabs-scrollbar');
const tabsScrollbarThumb = document.getElementById('tabs-scrollbar-thumb');
let tabsScrollbarDragging = false;
let tabsScrollbarDragStartX = 0;
let tabsScrollbarDragStartScrollLeft = 0;

function syncTabsScrollbar() {
    if (!tabsContainer || !tabsScrollbar || !tabsScrollbarThumb) return;

    const scrollW = tabsContainer.scrollWidth;
    const clientW = tabsContainer.clientWidth;
    const maxScroll = Math.max(0, scrollW - clientW);

    if (maxScroll <= 0) {
        tabsScrollbar.style.display = 'none';
        return;
    }

    tabsScrollbar.style.display = 'block';
    const trackW = tabsScrollbar.clientWidth;
    if (trackW <= 0) return;

    const thumbW = Math.max(24, Math.floor((clientW / scrollW) * trackW));
    const maxThumbX = Math.max(0, trackW - thumbW);
    const ratio = maxScroll === 0 ? 0 : (tabsContainer.scrollLeft / maxScroll);
    const thumbX = Math.round(ratio * maxThumbX);

    tabsScrollbarThumb.style.width = thumbW + 'px';
    tabsScrollbarThumb.style.transform = `translateX(${thumbX}px)`;
}

function renderTabs() {
    tabsContainer.innerHTML = '';
    tabs.forEach((tab, idx) => {
        const el = document.createElement('div');
        el.className = 'tab' + (tab.id === activeTabId ? ' active' : '');
        el.title = tab.name;
        const icon = document.createElementNS('http://www.w3.org/2000/svg','svg');
        icon.setAttribute('class','tab-icon'); icon.setAttribute('viewBox','0 0 24 24'); icon.setAttribute('fill','currentColor');
        icon.innerHTML = '<path d="M6 17h3l2-4V7H5v6h3zm8 0h3l2-4V7h-6v6h3z"/>';
        el.appendChild(icon);
        const name = document.createElement('span'); name.className = 'tab-name'; name.textContent = tab.name;
        name.addEventListener('dblclick', () => startRename(tab, name));
        el.appendChild(name);
        if (idx !== 0) {
            const x = document.createElement('button'); x.className = 'tab-close-btn'; x.innerHTML = '&times;'; x.title = 'Close';
            x.onclick = e => { e.stopPropagation(); removeTab(tab.id); };
            el.appendChild(x);
        }
        el.onclick = () => switchTab(tab.id);
        tabsContainer.appendChild(el);
    });
    // Keep overlay scrollbar in sync (after layout)
    requestAnimationFrame(syncTabsScrollbar);
}

function addTab(name = null, content = null) {
    tabCounter++;
    const id = 'tab-' + tabCounter;
    tabs.push({ id, name: name || 'Untitled Tab ' + tabCounter, content: content ?? initialContent });
    switchTab(id);
    queueSaveTabs();
}
function switchTab(id) {
    activeTabId = id;
    const tab = tabs.find(t => t.id === id);
    if (tab && monacoEditor) { monacoEditor.setValue(tab.content || ''); monacoEditor.focus(); }
    renderTabs();
    requestAnimationFrame(syncTabsScrollbar);
    updateOutlineSidebarDebounced();
    queueSaveTabs();
}
function removeTab(id) {
    const idx = tabs.findIndex(t => t.id === id);
    if (idx <= 0) return;
    tabs.splice(idx, 1);
    if (tabs.length === 1) tabCounter = 1;
    if (activeTabId === id) switchTab(tabs[Math.max(0, idx - 1)].id);
    else renderTabs();
    requestAnimationFrame(syncTabsScrollbar);
    queueSaveTabs();
}
function startRename(tab, span) {
    span.style.display = 'none';
    const inp = document.createElement('input'); inp.type='text'; inp.className='tab-name-input'; inp.value=tab.name;
    span.parentNode.insertBefore(inp, span); inp.focus(); inp.select();
    const done = () => { tab.name = inp.value.trim() || tab.name; inp.remove(); span.textContent=tab.name; span.style.display=''; queueSaveTabs(); };
    inp.addEventListener('blur', done);
    inp.addEventListener('keydown', e => { if(e.key==='Enter') done(); if(e.key==='Escape'){inp.remove();span.style.display='';} });
}

// ══════════════════════════════
// VIEWS
// ══════════════════════════════
const $ = id => document.getElementById(id);
let appContainer, editorView, settingsView, themeView, tabBar, actionBar, appBody;
let navEditor, navSettings, navTheme;

function showEditor()   { editorView.style.display='flex'; settingsView.style.display='none'; themeView.style.display='none'; tabBar.style.display='flex'; actionBar.style.display='flex'; appBody.className=''; }
function showSettings() { editorView.style.display='none'; settingsView.style.display='block'; themeView.style.display='none'; tabBar.style.display='none'; actionBar.style.display='none'; appBody.className='settings-active'; scanPorts(); }
function showTheme()    { editorView.style.display='none'; settingsView.style.display='none'; themeView.style.display='block'; tabBar.style.display='none'; actionBar.style.display='none'; appBody.className='theme-active'; }
function setNav(active) { [navEditor,navSettings,navTheme].forEach(n=>n.classList.remove('active-section-indicator')); active.classList.add('active-section-indicator'); }

function setThemeBase(base) {
    const isLight = base === 'light';
    document.documentElement.classList.toggle('light-theme', isLight);
    document.body.classList.toggle('light-theme', isLight);
    appContainer?.classList.toggle('light-theme', isLight);
    if (monacoEditor) monaco.editor.setTheme(isLight ? 'vs' : 'vs-dark');
}

function clearAppliedCustomThemeVars() {
    if (!appliedCustomVarNames?.length) return;
    appliedCustomVarNames.forEach(k => document.documentElement.style.removeProperty(k));
    appliedCustomVarNames = [];
}

function applyThemeVisualOnly(name) {
    // Apply theme visuals only (used for hover preview). No persistence, no renderThemeOptions, no saveSettings.
    if (typeof name === 'string' && name.startsWith('custom:')) {
        const id = name.slice('custom:'.length);
        const theme = customThemes.find(t => t.id === id);
        if (!theme) {
            clearAppliedCustomThemeVars();
            setThemeBase('dark');
            return;
        }

        setThemeBase(theme.base === 'light' ? 'light' : 'dark');
        clearAppliedCustomThemeVars();

        const vars = theme.vars && typeof theme.vars === 'object' ? theme.vars : {};
        for (const [k, v] of Object.entries(vars)) {
            if (!k.startsWith('--')) continue;
            document.documentElement.style.setProperty(k, String(v));
            appliedCustomVarNames.push(k);
        }

        // Monaco theme (optional)
        if (theme.monacoTheme && window.monaco?.editor?.defineTheme && monacoEditor) {
            try {
                monaco.editor.defineTheme('potassium-custom', {
                    base: theme.monacoTheme.base === 'vs' ? 'vs' : 'vs-dark',
                    inherit: theme.monacoTheme.inherit !== false,
                    rules: Array.isArray(theme.monacoTheme.rules) ? theme.monacoTheme.rules : [],
                    colors: (theme.monacoTheme.colors && typeof theme.monacoTheme.colors === 'object') ? theme.monacoTheme.colors : {},
                });
                monaco.editor.setTheme('potassium-custom');
            } catch (_) {}
        }
        return;
    }

    clearAppliedCustomThemeVars();
    setThemeBase(name === 'light' ? 'light' : 'dark');
}

function applyCustomTheme(id) {
    const theme = customThemes.find(t => t.id === id);
    if (!theme) {
        applyTheme('dark');
        return;
    }

    const base = theme.base === 'light' ? 'light' : 'dark';
    setThemeBase(base);

    clearAppliedCustomThemeVars();
    const vars = theme.vars && typeof theme.vars === 'object' ? theme.vars : {};
    for (const [k, v] of Object.entries(vars)) {
        if (!k.startsWith('--')) continue;
        document.documentElement.style.setProperty(k, String(v));
        appliedCustomVarNames.push(k);
    }

    // Monaco theme (optional)
    if (theme.monacoTheme && window.monaco?.editor?.defineTheme && monacoEditor) {
        try {
            monaco.editor.defineTheme('potassium-custom', {
                base: theme.monacoTheme.base === 'vs' ? 'vs' : 'vs-dark',
                inherit: theme.monacoTheme.inherit !== false,
                rules: Array.isArray(theme.monacoTheme.rules) ? theme.monacoTheme.rules : [],
                colors: (theme.monacoTheme.colors && typeof theme.monacoTheme.colors === 'object') ? theme.monacoTheme.colors : {},
            });
            monaco.editor.setTheme('potassium-custom');
        } catch (_) {}
    }

    themeName = 'custom:' + id;
    renderThemeOptions();
    if (!settingsApplying) saveSettings();
}

function applyTheme(name) {
    if (typeof name === 'string' && name.startsWith('custom:')) {
        const id = name.slice('custom:'.length);
        applyCustomTheme(id);
        return;
    }

    themeName = name === 'light' ? 'light' : 'dark';
    clearAppliedCustomThemeVars();
    setThemeBase(themeName);
    renderThemeOptions();
    if (!settingsApplying) saveSettings();
}

function renderThemeOptions() {
    const host = $('theme-options');
    if (!host) return;

    host.innerHTML = '';
    let previewOriginalTheme = null;

    const addOpt = ({ id, label, base, removable, onApply, onRemove }) => {
        const opt = document.createElement('div');
        opt.className = 'theme-opt';

        const main = document.createElement('div');
        main.className = 'theme-opt-main';

        const prev = document.createElement('div');
        prev.className = 'theme-preview ' + (base === 'light' ? 'tp-light' : 'tp-dark');
        prev.innerHTML = '<div class="ph"></div><div class="pb"></div>';

        const lbl = document.createElement('span');
        lbl.className = 'theme-lbl';
        lbl.textContent = label;

        main.append(prev, lbl);

        const right = document.createElement('div');
        right.className = 'theme-opt-right';

        if (removable) {
            const x = document.createElement('button');
            x.className = 'theme-remove-btn';
            x.type = 'button';
            x.textContent = '\u00D7';
            x.title = 'Remove theme';
            x.addEventListener('click', (e) => { e.stopPropagation(); onRemove?.(); });
            right.appendChild(x);
        }

        opt.append(main, right);
        opt.addEventListener('click', () => onApply?.());
        opt.addEventListener('mouseenter', () => {
            if (previewOriginalTheme == null) previewOriginalTheme = themeName;
            applyThemeVisualOnly(id);
        });
        opt.addEventListener('mouseleave', () => {
            if (previewOriginalTheme == null) return;
            applyThemeVisualOnly(previewOriginalTheme);
            previewOriginalTheme = null;
        });

        const active =
            (id === 'dark'  && themeName === 'dark') ||
            (id === 'light' && themeName === 'light') ||
            (id.startsWith('custom:') && themeName === id);
        if (active) opt.classList.add('active-theme');

        host.appendChild(opt);
    };

    addOpt({ id: 'dark', label: 'Default Dark', base: 'dark', removable: false, onApply: () => applyTheme('dark') });
    addOpt({ id: 'light', label: 'Light Theme', base: 'light', removable: false, onApply: () => applyTheme('light') });

    if (customThemeEnabled) {
        customThemes.forEach(t => {
            const id = 'custom:' + t.id;
            addOpt({
                id,
                label: t.name,
                base: t.base === 'light' ? 'light' : 'dark',
                removable: true,
                onApply: () => applyTheme(id),
                onRemove: () => {
                    customThemes = customThemes.filter(x => x.id !== t.id);
                    saveCustomThemes();
                    if (themeName === id) applyTheme('dark');
                    renderThemeOptions();
                },
            });
        });
    } else {
        if (typeof themeName === 'string' && themeName.startsWith('custom:')) applyTheme('dark');
    }
}

function themeTemplateText() {
    return `{
  "name": "My Custom Theme",
  "base": "dark",
  "_instructions": [
    "Keep \\\"name\\\" unique so you can identify it in Appearance.",
    "\\\"base\\\" controls the Light/Dark base styles: \\\"light\\\" or \\\"dark\\\".",
    "\\\"vars\\\" overrides CSS variables used across the UI. Only include what you want to change.",
    "Then go to Settings > Window > Custom Theme and click \\\"Add\\\" while this tab is active."
  ],
  "monacoTheme": {
    "_note": "Optional. If present, Monaco will use this theme (defineTheme + setTheme).",
    "base": "vs-dark",
    "inherit": true,
    "rules": [],
    "colors": {
      "editor.background": "#1a1a1a"
    }
  },
  "vars": {
    "--bg-primary": "#181818",
    "--bg-secondary": "#1a1a1a",
    "--bg-tertiary": "#2a2a2a",
    "--bg-accent": "#222222",
    "--text-primary": "#d0d0d0",
    "--text-secondary": "#888888",
    "--text-tertiary": "#606060",
    "--accent": "#a0a0a0",
    "--accent-dim": "#555555",
    "--red": "#b85555",
    "--border-primary": "#282828",
    "--border-secondary": "#1f1f1f",
    "--border-accent": "#303030",
    "--toggle-bg": "#3a3a3c",
    "--toggle-border": "#505050",
    "--toggle-knob-off": "#888888",
    "--toggle-knob-on": "#ffffff",
    "--dot-off": "#444444",
    "--dot-muted": "#555555",
    "--badge-bg": "rgba(255,255,255,.04)",
    "--conn-bg": "rgba(160,160,160,.06)",
    "--overlay-bg": "rgba(0,0,0,.6)",
    "--shadow-panel": "0 10px 28px rgba(0,0,0,.55)",
    "--shadow-panel-strong": "0 10px 30px rgba(0,0,0,.6)",
    "--shadow-modal": "0 14px 42px rgba(0,0,0,.6)",
    "--theme-glow": "0 0 10px rgba(160,160,160,.12)"
  }
}`;
}

function parseThemeJson(text) {
    let parsed;
    try {
        parsed = JSON.parse(String(text || ''));
    } catch (e) {
        throw new Error('Theme JSON must be valid JSON (no comments or trailing commas). ' + (e?.message || e));
    }
    if (!parsed || typeof parsed !== 'object') throw new Error('Theme JSON must be an object.');

    const name = String(parsed.name || '').trim();
    if (!name) throw new Error('Theme must have a non-empty "name".');

    const base = parsed.base === 'light' ? 'light' : 'dark';
    const vars = parsed.vars;
    if (!vars || typeof vars !== 'object' || Array.isArray(vars)) throw new Error('Theme must have a "vars" object.');

    const cleaned = {};
    for (const [k, v] of Object.entries(vars)) {
        const key = String(k || '').trim();
        if (!key.startsWith('--')) continue;
        const val = String(v ?? '').trim();
        if (!val) continue;
        cleaned[key] = val;
    }
    if (!Object.keys(cleaned).length) throw new Error('Theme "vars" is empty (no valid CSS variables).');

    const monacoTheme = parsed.monacoTheme;
    if (monacoTheme != null) {
        if (!monacoTheme || typeof monacoTheme !== 'object' || Array.isArray(monacoTheme)) throw new Error('"monacoTheme" must be an object.');
        const baseM = monacoTheme.base === 'vs' ? 'vs' : 'vs-dark';
        const inherit = monacoTheme.inherit !== false;
        const rules = Array.isArray(monacoTheme.rules) ? monacoTheme.rules : [];
        const colors = (monacoTheme.colors && typeof monacoTheme.colors === 'object' && !Array.isArray(monacoTheme.colors)) ? monacoTheme.colors : {};
        return { name, base, vars: cleaned, monacoTheme: { base: baseM, inherit, rules, colors } };
    }

    return { name, base, vars: cleaned, monacoTheme: null };
}

async function importThemeFromFile() {
    // Tauri
    if (window.__TAURI__) {
        try {
            const r = await tauriInvoke('open_file_dialog');
            if (r?.content) return String(r.content);
        } catch(_) {}
    }

    // Browser fallback
    return await new Promise((resolve, reject) => {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json,application/json,text/plain';
        input.onchange = async () => {
            try {
                const file = input.files?.[0];
                if (!file) return reject(new Error('No file selected.'));
                const text = await file.text();
                resolve(text);
            } catch (e) { reject(e); }
        };
        input.click();
    });
}

function normalizeThemeName(name) {
    return String(name || '').trim().toLowerCase();
}

function isReservedThemeName(name) {
    const n = normalizeThemeName(name);
    return n === 'default dark' || n === 'light theme' || n === 'dark' || n === 'light';
}

async function upsertCustomTheme(parsedTheme) {
    if (isReservedThemeName(parsedTheme.name)) {
        throw new Error('You can\u2019t replace built-in themes (Default Dark / Light Theme). Choose a different "name".');
    }

    const n = normalizeThemeName(parsedTheme.name);
    const idx = customThemes.findIndex(t => normalizeThemeName(t.name) === n);

    if (idx >= 0) {
        if (!autoReplaceThemeOnConflict) {
            const ok = await confirmModal(`A theme named "${customThemes[idx].name}" already exists. Replace it?`, 'Replace', 'Cancel');
            if (!ok) return null;
        }
        const existing = customThemes[idx];
        customThemes[idx] = {
            ...existing,
            name: parsedTheme.name,
            base: parsedTheme.base,
            vars: parsedTheme.vars,
            monacoTheme: parsedTheme.monacoTheme ?? null,
        };
        saveCustomThemes();
        renderThemeOptions();
        return existing.id;
    }

    const id = 't' + Date.now().toString(36) + Math.random().toString(36).slice(2, 7);
    customThemes.push({ id, name: parsedTheme.name, base: parsedTheme.base, vars: parsedTheme.vars, monacoTheme: parsedTheme.monacoTheme ?? null });
    saveCustomThemes();
    renderThemeOptions();
    return id;
}

// ══════════════════════════════
// INIT
// ══════════════════════════════
function init() {
    appContainer = $('app-container');
    editorView   = $('editor-view');
    settingsView = $('settings-view');
    themeView    = $('theme-view');
    tabBar       = $('tab-bar');
    actionBar    = $('action-bar');
    appBody      = $('app-body');
    navEditor    = $('nav-editor');
    navSettings  = $('nav-settings');
    navTheme     = $('nav-theme');
    rightSidebarEl = $('right-sidebar');

    navEditor.classList.add('active-section-indicator');
    showEditor();

    // Apply persisted settings (theme, toggles, dropdowns, etc.)
    customThemes = loadCustomThemes();
    applySettings(loadSettings());

    // Nav
    navEditor.onclick   = () => { showEditor();   setNav(navEditor); };
    navSettings.onclick = () => { showSettings(); setNav(navSettings); };
    navTheme.onclick    = () => { showTheme();    setNav(navTheme); };

    // Theme
    renderThemeOptions();

    const openTabAndGoEditor = (name, content) => {
        addTab(name, content);
        showEditor();
        setNav(navEditor);
    };

    // Editor toggles
    $('tog-minimap').addEventListener('change', e => { monacoEditor?.updateOptions({ minimap: { enabled: e.target.checked } }); if(!settingsApplying) saveSettings(); });
    $('tog-linenums').addEventListener('change', e => { monacoEditor?.updateOptions({ lineNumbers: e.target.checked ? 'on' : 'off' }); if(!settingsApplying) saveSettings(); });
    $('tog-smooth-typing').addEventListener('change', e => {
        smoothTyping = !!e.target.checked;
        monacoEditor?.updateOptions({
            smoothScrolling: smoothTyping,
            cursorBlinking: smoothTyping ? 'smooth' : 'blink',
            cursorSmoothCaretAnimation: smoothTyping ? 'on' : 'off',
        });
        if(!settingsApplying) saveSettings();
    });
    $('tog-outline-sidebar').addEventListener('change', e => {
        outlineSidebar = !!e.target.checked;
        updateOutlineSidebar();
        if(!settingsApplying) saveSettings();
    });
    $('tog-autosave-tabs').addEventListener('change', e => {
        autosaveTabs = !!e.target.checked;
        if (!autosaveTabs) clearSavedTabs();
        else saveTabsNow();
        if(!settingsApplying) saveSettings();
    });
    $('tog-custom-theme').addEventListener('change', e => {
        customThemeEnabled = !!e.target.checked;
        const box = $('custom-theme-settings');
        if (box) box.style.display = customThemeEnabled ? 'block' : 'none';
        if (!customThemeEnabled && typeof themeName === 'string' && themeName.startsWith('custom:')) applyTheme('dark');
        renderThemeOptions();
        if(!settingsApplying) saveSettings();
    });
    $('tog-theme-auto-replace').addEventListener('change', e => {
        autoReplaceThemeOnConflict = !!e.target.checked;
        if(!settingsApplying) saveSettings();
    });

    $('btn-theme-template').addEventListener('click', () => {
        openTabAndGoEditor('theme-template.json', themeTemplateText());
    });
    $('btn-theme-import').addEventListener('click', async () => {
        try {
            const text = await importThemeFromFile();
            const t = parseThemeJson(text);
            const id = await upsertCustomTheme(t);
            if (!id) return;
            customThemeEnabled = true;
            $('tog-custom-theme').checked = true;
            $('custom-theme-settings').style.display = 'block';
            renderThemeOptions();
            applyTheme('custom:' + id);
            if(!settingsApplying) saveSettings();
        } catch (e) {
            modal('Theme import error: ' + (e?.message || e));
        }
    });
    $('btn-theme-add').addEventListener('click', async () => {
        try {
            if (!monacoEditor) throw new Error('Editor not ready.');
            const text = monacoEditor.getValue();
            const t = parseThemeJson(text);
            const id = await upsertCustomTheme(t);
            if (!id) return;
            customThemeEnabled = true;
            $('tog-custom-theme').checked = true;
            $('custom-theme-settings').style.display = 'block';
            renderThemeOptions();
            applyTheme('custom:' + id);
            if(!settingsApplying) saveSettings();
        } catch (e) {
            modal('Add theme error: ' + (e?.message || e));
        }
    });

    $('btn-open-functions')?.addEventListener('click', async () => {
        const text = await fetchFunctionsTxt();
        openTabAndGoEditor('functions.txt', text || '');
    });

    // Always on top
    $('tog-aot').addEventListener('change', async e => {
        try { await tauriInvoke('set_always_on_top', { value: e.target.checked }); } catch(_) {}
        if(!settingsApplying) saveSettings();
    });

    // Auto Attach
    $('tog-auto-attach').addEventListener('change', e => { e.target.checked ? startAutoAttach(false) : stopAutoAttach(); if(!settingsApplying) saveSettings(); });

    // API Backend CDD
    $('cdd-api-trigger').onclick = e => { e.stopPropagation(); toggleCdd('cdd-api-panel','cdd-api-trigger'); };
    document.getElementById('cdd-api-panel')?.querySelectorAll('.cdd-item').forEach(item => {
        item.addEventListener('click', () => {
            apiBackend = item.dataset.value;
            document.getElementById('cdd-api-label').textContent = item.querySelector('.cdd-item-left').textContent.trim();
            document.getElementById('cdd-api-panel').querySelectorAll('.cdd-item').forEach(i => i.classList.remove('active'));
            item.classList.add('active');
            closeCdd('cdd-api-panel', 'cdd-api-trigger');
            console.log('[Settings] API backend set to:', apiBackend);
            if(!settingsApplying) saveSettings();
        });
    });

    // Notification toggles
    $('tog-notif-execute').addEventListener('change', e => { notifExecute = e.target.checked; if(!settingsApplying) saveSettings(); });
    $('tog-notif-attach').addEventListener('change',  e => { notifAttach  = e.target.checked; if(!settingsApplying) saveSettings(); });

    // ── Custom dropdowns ──
    // Port CDD
    $('cdd-port-trigger').onclick = e => { e.stopPropagation(); toggleCdd('cdd-port-panel','cdd-port-trigger'); if(openCdds.has('cdd-port-panel')) scanPorts(); };
    renderPortCddPanel();
    refreshPortCddTrigger();

    // Attach CDD
    $('cdd-attach-trigger').onclick = e => { e.stopPropagation(); toggleCdd('cdd-attach-panel','cdd-attach-trigger'); };
    setupAttachCdd();

    // Execute CDD
    $('cdd-execute-trigger').onclick = e => { e.stopPropagation(); toggleCdd('cdd-execute-panel','cdd-execute-trigger'); };
    setupExecuteCdd();

    // ── Main action-bar Attach button + caret ──
    $('attach-btn').onclick = () => (attachMode === 'any' ? attachToAny(false) : attachToPort(selectedPort, false));
    $('attach-caret').onclick = e => { e.stopPropagation(); toggleMainDd(); };
    $('dd-attach-any').onclick = () => { closeMainDd(); attachToAny(false); };
    $('dd-detach').onclick     = () => { closeMainDd(); detach(); };

    // Window controls
    $('wcbtn-min').onclick = () => tauriInvoke('minimize_window').catch(() => window.__TAURI__?.window?.getCurrent()?.minimize());
    $('wcbtn-max').onclick = () => tauriInvoke('toggle_maximize').catch(() => window.__TAURI__?.window?.getCurrent()?.toggleMaximize());
    $('wcbtn-close').onclick = async () => {
        saveTabsNow();
        stopAutoAttach(); await detach();
        tauriInvoke('close_window').catch(() => window.__TAURI__?.window?.getCurrent()?.close().catch(() => window.close()));
    };

    // Execute — reads from Monaco, uses selected API backend
    $('btn-execute').onclick = async () => {
        if (!monacoEditor) { modal('Editor not ready.'); return; }

        const code = toOpiumwarePacket(monacoEditor.getValue());
        if (!code) { modal('Editor is empty.'); return; }

        const port = executeTarget === 'ALL'
            ? 'ALL'
            : (selectedPort || '8392');

        const btn = $('btn-execute');
        btn.disabled = true;
        const origHTML = btn.innerHTML;
        btn.innerHTML = origHTML.replace('Execute', 'Running...');

        try {
            let result;
            if (apiBackend === 'js') {
                result = await jsApiExecute(code, port);
            } else {
                result = await tauriInvoke('OpiumwareExecution', { code, port });
            }
            console.log('[Execute] result:', result);
            if (notifExecute) modal(result || 'Executed.');
            if (result && result.toLowerCase().includes('successfully')) {
                const m = result.match(/port[: ]+(\d+)/i);
                if (m && !connectedPort) setConnectedPort(m[1]);
            }
        } catch(e) {
            console.error('[Execute] error:', e);
            modal('Execute error: ' + String(e));
        } finally {
            btn.disabled = false;
            btn.innerHTML = origHTML;
        }
    };

    $('btn-clear').onclick = () => monacoEditor?.setValue('');
    $('btn-open').onclick  = async () => {
        // Try Tauri first, fall back to browser file picker
        if (window.__TAURI__) {
            try { const r = await tauriInvoke('open_file_dialog'); if(r) addTab(r.name, r.content); return; } catch(_) {}
        }
        // Browser fallback
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.lua,.txt,*';
        input.onchange = async () => {
            const file = input.files[0];
            if (!file) return;
            const text = await file.text();
            addTab(file.name, text);
        };
        input.click();
    };
    $('btn-save').onclick  = async () => {
        const tab = tabs.find(t=>t.id===activeTabId); if(!tab) return;
        const content = monacoEditor?.getValue() || '';
        // Try Tauri first, fall back to browser download
        if (window.__TAURI__) {
            try { await tauriInvoke('save_file_dialog', { content, suggested_name: tab.name }); return; } catch(_) {}
        }
        // Browser fallback — triggers a download
        const blob = new Blob([content], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = tab.name.endsWith('.lua') || tab.name.endsWith('.txt') ? tab.name : tab.name + '.lua';
        a.click();
        URL.revokeObjectURL(url);
    };
    $('add-tab-btn').onclick = () => addTab();

    // Search input:
    // - If Outline View is enabled, it filters the outline sidebar.
    // - Otherwise, it triggers Monaco's find widget.
    $('tab-bar-search-input').addEventListener('input', e => {
        const q = e.target.value || '';

        if (outlineSidebar) {
            outlineSearchQuery = q;
            updateOutlineSidebarDebounced();
            return;
        }

        if (!monacoEditor) return;
        if (q) {
            monacoEditor.trigger('search', 'actions.find', null);
            // Use Monaco's find controller
            const fc = monacoEditor.getContribution('editor.contrib.findController');
            if (fc) { fc.start({ searchString: q, replaceString: '', isRegex: false, matchCase: false, matchWholeWord: false }); }
        } else {
            monacoEditor.getAction('closeReferenceSearch')?.run();
            monacoEditor.focus();
        }
    });
    $('tab-bar-search-input').addEventListener('keydown', e => {
        if (e.key === 'Escape') {
            e.target.value = '';
            if (outlineSidebar) { outlineSearchQuery = ''; updateOutlineSidebarDebounced(); }
            else monacoEditor?.focus();
        }
        if (e.key === 'Enter') {
            if (outlineSidebar) return;
            const fc = monacoEditor?.getContribution('editor.contrib.findController');
            if (fc) e.shiftKey ? fc.moveToPrevMatch() : fc.moveToNextMatch();
        }
    });

    // Tabs overflow scrollbar (overlay)
    tabsContainer?.addEventListener('scroll', () => requestAnimationFrame(syncTabsScrollbar));
    window.addEventListener('resize', () => requestAnimationFrame(syncTabsScrollbar));

    // Thumb dragging
    tabsScrollbarThumb?.addEventListener('mousedown', e => {
        e.preventDefault();
        e.stopPropagation();
        tabsScrollbarDragging = true;
        tabsScrollbarDragStartX = e.clientX;
        tabsScrollbarDragStartScrollLeft = tabsContainer.scrollLeft;
        document.body.style.userSelect = 'none';
    });
    document.addEventListener('mousemove', e => {
        if (!tabsScrollbarDragging) return;
        const scrollW = tabsContainer.scrollWidth;
        const clientW = tabsContainer.clientWidth;
        const maxScroll = Math.max(0, scrollW - clientW);
        const trackW = tabsScrollbar.clientWidth;
        const thumbW = tabsScrollbarThumb.getBoundingClientRect().width;
        const maxThumbX = Math.max(0, trackW - thumbW);
        if (maxScroll === 0 || maxThumbX === 0) return;
        const dx = e.clientX - tabsScrollbarDragStartX;
        const scrollDx = (dx / maxThumbX) * maxScroll;
        tabsContainer.scrollLeft = tabsScrollbarDragStartScrollLeft + scrollDx;
        syncTabsScrollbar();
    });
    document.addEventListener('mouseup', () => {
        if (!tabsScrollbarDragging) return;
        tabsScrollbarDragging = false;
        document.body.style.userSelect = '';
    });

    // Click track to jump
    tabsScrollbar?.addEventListener('mousedown', e => {
        if (e.target === tabsScrollbarThumb) return;
        const rect = tabsScrollbar.getBoundingClientRect();
        const x = Math.max(0, Math.min(rect.width, e.clientX - rect.left));
        const scrollW = tabsContainer.scrollWidth;
        const clientW = tabsContainer.clientWidth;
        const maxScroll = Math.max(0, scrollW - clientW);
        const trackW = rect.width;
        const thumbW = tabsScrollbarThumb.getBoundingClientRect().width;
        const maxThumbX = Math.max(0, trackW - thumbW);
        if (maxScroll === 0 || maxThumbX === 0) return;
        const thumbTargetX = Math.max(0, Math.min(maxThumbX, x - thumbW / 2));
        const ratio = thumbTargetX / maxThumbX;
        tabsContainer.scrollLeft = ratio * maxScroll;
        syncTabsScrollbar();
    });

    renderMainDdPorts();
}

// ══════════════════════════════
// MONACO BOOTSTRAP
// ══════════════════════════════
require.config({ paths: { vs: 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.47.0/min/vs' } });
require(['vs/editor/editor.main'], () => {
    monacoEditor = monaco.editor.create($('monaco-container'), {
        value: '', language: 'lua', theme: 'vs-dark',
        automaticLayout: true, fontSize: 12,
        minimap: { enabled: false }, lineNumbers: 'on',
        smoothScrolling: true,
        cursorBlinking: 'smooth',
        cursorSmoothCaretAnimation: 'on',
        scrollbar: { verticalScrollbarSize: 8, horizontalScrollbarSize: 8, useShadows: false, vertical: 'auto', horizontal: 'auto' },
        lineNumbersMinChars: 3, padding: { top: 8 }
    });

    init();
    restoreTabsOrDefault();

    monacoEditor.onDidChangeModelContent(() => {
        const tab = tabs.find(t => t.id === activeTabId);
        if (tab) tab.content = monacoEditor.getValue();
        updateOutlineSidebarDebounced();
        queueSaveTabs();
    });

    // Sync toggle states with actual editor options
    $('tog-minimap').checked = monacoEditor.getOption(monaco.editor.EditorOption.minimap).enabled;
    const lnOpt = monacoEditor.getOption(monaco.editor.EditorOption.lineNumbers);
    $('tog-linenums').checked = lnOpt?.renderType !== 0;
    $('tog-smooth-typing').checked = smoothTyping;
});
</script>
</body>
</html>
